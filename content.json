{"meta":{"title":"Leida","subtitle":null,"description":"雷答在 Github 上的个人博客","author":"Lei da","url":"http://curiousLei.github.io"},"pages":[],"posts":[{"title":"centos7中搭建ftp服务","slug":"setFTPServerInCentos7","date":"2019-12-17T14:16:32.540Z","updated":"2019-12-17T14:33:02.550Z","comments":true,"path":"2019/12/17/setFTPServerInCentos7/","link":"","permalink":"http://curiousLei.github.io/2019/12/17/setFTPServerInCentos7/","excerpt":"","text":"最近想和同学共享一些文件资源，于是在实验室服务器上搭建个ftp服务，本博客记录一下配置的流程。过程基本是参照别人的方法来做的，博客也是在别人博客基础上修改的，当然排除了一些坑点。 参考：https://www.cnblogs.com/jefflee168/p/6575014.html 1. 安装vsftpd 安装vsftpd： yum install vsftpd -y 启动vsftpd： systemctl start vsftpd 设置开机启动：systemctl enable vsftpd 创建ftp根目录： mkdir -p /ftpserver 2. 设置配置文件vim /etc/vsftpd/vsftpd.conf1234567891011121314151617181920listen=YES // 需要把ipv6那个改成NO，两个不能同时开启#禁止匿名访问anonymous_enable=NOanon_upload_enable=NOanon_mkdir_write_enable=NOanon_other_write_enable=NOchroot_list_enable=NO // 不允许用户离开自己的主目录chroot_list_file=/etc/vsftpd.chroot_list // 虚拟用户列表，每行一个用户名local_enable=YES // 允许本地用户访问write_enable=YES // 允许本地用户写入local_umask=022 // 上传后的文件的默认掩码chroot_local_user=YES // 禁止本地用户离开自己的主目录pam_service_name=vsftpd // 权限验证需要的加密文件guest_enable=YES // 开启虚拟用户功能guest_username=bt // 宿主用户，这个用户需要创建，或者使用已有用户，同样可以通过ftp来登录virtual_use_local_privs=YES // 用户登录后操作目录和本地用户权限一样user_config_dir=/etc/vsftpd/vconf // 虚拟用户主目录设置文件allow_writeable_chroot=YES // 允许写入用户主目录，这条特别重要 3. 添加虚拟用户，并创建用户目录 vim /etc/vsftpd.chroot_list，添加两个用户如进去，分别为： 123 user1 user2 mkdir -p /ftpserver/user1 /ftpserver/user2 // 创建用户目录 chmod –R 755 /ftpserver/user1 /ftpserver/user2 // 修改目录权限，如果希望用户有写入权限，给other添加写权限即可，例如777 指定用户目录 12345678910mkdir –p /etc/vsftpd/vconfcd /etc/vsftpd/vconftouch user1 user2# vim user1 local_root=/ftpserver/user1#vim user2 local_root=/ftpserver/user2 4. 设置用户密码和数据库1234567echo -e &quot;user1\\n123456\\nuser2\\n123456&quot; &gt;/etc/vsftpd/vusers.liscd /etc/vsftpddb_load –T –t hash –f vusers.list vusers.dbchmod 600 vusers.* 5. 指定登录认证方式vim /etc/pam.d/vsftpd修改为如下12auth sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/vusersaccount sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/vusers 6. 关闭SELINUX的屏蔽123456vi /etc/selinux/config #SELINUX=enforcing #注释掉 SELINUX=disabled #增加setenforce 0 #使配置立即生效 最后 systemctl restart vsftpd即可","categories":[],"tags":[]},{"title":"java字符编码-Unicode编码问题刨根究底","slug":"encodingAnalyze","date":"2019-12-02T09:11:38.973Z","updated":"2019-12-05T07:50:11.894Z","comments":true,"path":"2019/12/02/encodingAnalyze/","link":"","permalink":"http://curiousLei.github.io/2019/12/02/encodingAnalyze/","excerpt":"","text":"前段时间在读《java核心技术卷一》，遇到一些名词：码点、代码单元等，其实字面意思不难理解，解释如下 码点(code point)：Unicode编码表中某个字符对应的代码值 代码单元(code unit)：用于UTF-16编码的最小单元，16个bit 注意上述只是针对java中字符和字符串的Unicode+UTF-16机制的解释。若是其他编码方式就另说，如UTF-8的代码单元是用8个bit编码。 下面问题来了 书中建议，尽量不要使用char类型，最好将字符串转化为抽象数据类型来处理，即codepoints数组 12//将String转化为码点数组int[] codePoints = str.codePoints().toArray(); 那么为什么要这样做呢，像c语言那样直接使用char数组不好吗？当然不行，因为在Unicode+UTF-16这种机制中，一个码点可由一个代码单元表示，但很多特殊字符也可能由两个代码单元表示。而char类型只能是一个代码单元。所以，若字符串中存在特殊字符，遍历char数组或者使用charAt等方法时就会出问题。但使用码点数组就OK，因为数组中每一个元素都代表一个码点，而不是一个代码单元。而c语言中采用ASCII字符集，每个码点都由一个8bit代码单元表示，使用char数组则不存在这个问题。 这样的描述对懂Unicode和UTF-16的人来说，很容易理解。但我想在我的博客中深究一下编码机制背后的原理。为了便于小白理解，先介绍一下编码规范的基本概念。 编码规范制定编码规范为了将计算机能识别的二进制数，映射成人类能识别的字符。依据编码规范，计算机就可以将二进制数显示成字符。常见的编码规范有，ASCII码、GBK、ISO-8859-1、Unicode等。编码规范中有三个子概念，字库表、字符集、编码方式。 字库表字库表中存储该编码规范能表示的所有字符。一套编码规范不一定能表示世界上所有的字符。例如GBK规范可以显示汉字，但不能显示法语、俄语等。 字符集字库表中每一个字符都有一个二进制地址，字符集就是这些二进制数的集合。例如 00000000 - 01111111 为ASCII字符集的范围。 编码方式某些编码规范包括大量的字符，例如Unicode中包含上百万个字符。若每个字符都采用同样长度的二进制数来编码，即定长编码，则要用三个字节来存储，甚至在将来会用到四个字节。这样很多本身只需要单字节存储的字符也会占用三四个字节，会导致极大的资源浪费。 如果能采用一些算法，使得部分字符采用单字节编码，部分采用双字节等(即变长编码)，可节省不少资源，这些算法即为编码方式。常见的编码方式有UTF-8、UTF-16、UTF-32等。我前文所说的：Unicode+UTF-16机制，就容易理解了，即基于Unicode编码规范并采用UTF-16编码方式的机制。java中的字符串和字符正是采用这种机制进行编码的，下面详细介绍Unicode和UTF-16。 注意UTF的全称是Unicode Transformation Format，含义为将Unicode转换为某种格式。所以UTF-8、UTF-16等都是针对Unicode来说的。 Unicode在Unicode出现之前，已经有了很多编码规范，如美国的ASCII码、中国的GBK、西欧的ISO-8859-1等，每一种规范都不能涵盖所有国家的语言。Unicode设计的初衷就是将所有语言中的字符进行统一编码。 Unicode最早的1.0版本中，字符集数量远远不到65536，因为当时的字符集不是那么庞大，使用2个字节编码足够使用，java也正是此时引进了16位的Unicode字符集。 然而，在Unicode增加了大量的汉语、日语、韩语字符之后，字符数量超过了65536，于是16位的char类型也就不能满足了。实际上，这些海量的Unicode字符可以被划分为17个代码级别(code plane) 第一级别，基本多语言级别(basic multilingual plane)，范围U+0000~U+FFFF，下文称其为基本平面 其它16个级别，范围U+10000~U+10FFFF，存储辅助字符，下文把它称作增补平面 UTF-16编码则是对不同的代码级别做文章，采用不同长度的编码表示不同代码级别的码点 UTF-16UTF-16使用16位作为一个代码单元。基本平面的码点采用一个代码单元进行编码，增补平面的码点使用两个代码单元。 可能你会问，使用一对代码单元表示一个增补平面的字符时，有没有可能把它判别成两个基本平面的码点？也就是说，有没有可能出现冲突的情况？ 当然不会，UTF-16中使用了代理机制，即使用基本平面中未映射字符的字符集区域，来作为增补平面中字符的代码单元的区域 这些码点区域称为“替代区域”(syrrogate area)，即U+D800 ~ U+DFFF范围，该区域在基本平面中属于空闲区域，2048个值。如此一来，便避免了冲突。 该替代区域分割为两部分，U+D800 ~ U+DBFF用于第一个代码单元，U+DC00 ~ U+DFFF用于第二个代码单元。 代码单元1 代码单元2 1101 10pp ppxx xxxx 1101 11xx xxxx xxxx pppp是指16个级别的级别编号，2^4=16。两个代码单元的变数部分(p和x)共20位，可表示2^20=1048576个码点。而增补平面范围U+10000~U+10FFFF恰好也是1048576个码点。所以这两个代码单元可完美表示出增补平面中的所有字符。 这种方式十分巧妙。 事实上，只有UTF-16使用了“替代区域”方法，像现在被广泛接纳的UTF-8编码，是通过首字节的比特位判断码点的代码单元数量。 最后简单介绍下UTF-16和UTF-8的区别，以后再找时间细究，把UTF-8的坑填上。 UTF-16使用2个或4个字节进行编码，大部分汉字采用两个字节编码，少量汉字采用四个字节 UTF-8使用1个到4个字节编码，大部分汉字采用三个字节","categories":[],"tags":[]},{"title":"content-type常见类型辨析(以ajax与springmvc前后端交互为例)","slug":"frontEndDataInteraction","date":"2019-11-21T08:20:51.135Z","updated":"2019-11-26T10:34:43.017Z","comments":true,"path":"2019/11/21/frontEndDataInteraction/","link":"","permalink":"http://curiousLei.github.io/2019/11/21/frontEndDataInteraction/","excerpt":"","text":"在http报文的首部中，有一个字段Content-type，表示请求体（entity body）中的数据类型 1234类型格式：type/subtype(;parameter)? type主类型，任意的字符串,如text,如果*代表所有；子类型，任意字符串，如html，如果*代表所有；可选，如charset参数。 常见的媒体格式类型如下 text/html ： HTML格式 text/plain ：纯文本格式 text/xml ： XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png：png图片格式以application开头的媒体格式类型： application/xhtml+xml ：XHTML格式 application/xml ： XML数据格式 application/atom+xml ：Atom XML聚合格式 application/json ： JSON数据格式 application/pdf ：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ： 中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的： multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式 以上就是我们在日常的开发中，经常会用到的若干content-type的内容格式。接下来重点分析application/json、application/x-www-form-urlencoded和multipart/form-data，三个常用的内容格式 application/json我们常用的json数据格式，使用ajax发送此种数据请求，如下所示12345678910111213var dt=&#123; &quot;userName&quot;:&quot;leida&quot;, &quot;userPasswd&quot;:&quot;123456&quot;&#125;$.ajax(&#123; type:&quot;post&quot;, url:&quot;http://10.28.230.26:8080/login&quot;, data:JSON.stringify(dt), contentType: &quot;application/json&quot;, success : function(ret) &#123; console.log(&quot;logintest&quot;,ret) &#125;&#125;) 注意dt是一个js对象，需要通过JSON.stringify将其序列化为json字符串，再封装进请求体，此时报文的entity body如下所示此时，后台以如下形式接收参数（ParamDemo为自己定义的类）1234@PostMapping(&quot;/testJson&quot;)public Object testJson(@RequestBody ParamDemo paramDemo)&#123; return paramDemo;&#125; 我遇到一个问题，若按照如下所示发送请求，即不使用JSON.stringify（以前用PHP后台的时候一向是这么搞）此时会报400不能正常解析12345678910111213var dt=&#123; &quot;userName&quot;:&quot;leida&quot;, &quot;userPasswd&quot;:&quot;123456&quot;&#125;$.ajax(&#123; type:&quot;post&quot;, url:&quot;http://10.28.230.26:8080/login&quot;, data:dt, contentType: &quot;application/json&quot;, success : function(ret) &#123; console.log(&quot;logintest&quot;,ret) &#125;&#125;) 看了一下http报文，数据对象dt以key1=val1&amp;key2=val2 的方式进行编码,存在entity body中，如下图所示，就叫它键值对形式吧实际上，该种情况是可以被解析的，此时后台使用@RequestBody注解并使用String类型可以接收该键值对字符串：userName=leida&amp;userPasswd=123456，如下所示1234@PostMapping(&quot;/testJson&quot;)public Object testJson(@RequestBody String str)&#123; return str;&#125; 综上所述，若data参数为JSON.stringify转化好的类型，则被正常序列化为json字符串；若data参数为一个普通js对象，则会被序列化为键值对参数字符串形式，即userName=leida&amp;userPasswd=123456 application/x-www-form-urlencode这是ajax的contenttype的默认值，用于处理表单，会将表单数据序列化为键值对参数字符串形式，如下图所示可用HttpServletRequest 或者RequestBody 解析成字符串处理 application/form-data它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。1234567891011121314151617var formdata = new FormData($(&quot;#form&quot;)[0]);$.ajax(&#123; type : &quot;post&quot;, url : &quot;http://localhost:8080/roomInfoApply2&quot;, data : formdata, // 你的formid contentType:false,//ajax 中 contentType 设置为 false 是为了避免 JQuery 对其操作，从而失去分界符，而使服务器不能正常解析文件 processData: false, //当设置为true的时候,jquery ajax 提交的时候不会序列化 data，而是直接使用data error : function(request) &#123; layer.alert(&apos;操作失败&apos;, &#123; icon: 2, title:&quot;提示&quot; &#125;); &#125;, success : function(ret) &#123; console.log(ret) &#125;&#125;) 报文如下图所示后台使用如下方式接收数据123456789101112@PostMapping(&quot;/roomInfoApply2&quot;)public Object testFile(HttpServletRequest request, @RequestParam(value=&quot;confer_num&quot;,required=false) String num, @RequestParam(value=&quot;confer_date&quot;,required=false) String date, @RequestParam MultipartFile uploadFile) throws IOException &#123; System.out.println(uploadFile); String newFileName = &quot;123.xlsx&quot;; String imgPath = request.getServletContext().getRealPath(&quot;/files/&quot;) + newFileName; File newFile = new File(request.getServletContext().getRealPath(&quot;/files&quot;), newFileName); newFile.getParentFile().mkdirs(); uploadFile.transferTo(newFile); //response.addHeader(); return num+date+imgPath; //return testDataService.getAllTestData();&#125;","categories":[],"tags":[]},{"title":"springboot相关配置","slug":"springbootConfig","date":"2019-11-09T12:03:09.935Z","updated":"2019-11-09T12:04:21.790Z","comments":true,"path":"2019/11/09/springbootConfig/","link":"","permalink":"http://curiousLei.github.io/2019/11/09/springbootConfig/","excerpt":"","text":"配置mybatis application.properties中配置 1234567mybatis.mapper-location=classpath:com/leida/mapper/*.xml#配置数据库连接信息spring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3307/mls?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false pom.xml中添加以下配置 1234567891011121314151617181920212223242526272829303132&lt;!-- 继承springboot的父级项目依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;!-- 属性配置 --&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 开发web项目的起步依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--加载mybatis整合springboot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql的jdbc驱动包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写generatorConfig.xml，自动生成代码的根文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--导入属性配置 --&gt; &lt;properties resource=&quot;application.properties&quot;&gt;&lt;/properties&gt; &lt;!--指定特定数据库的jdbc驱动jar包的位置 --&gt; &lt;classPathEntry location=&quot;C:\\Users\\leida\\.m2\\repository\\mysql\\mysql-connector-java\\8.0.18\\mysql-connector-java-8.0.18.jar&quot;/&gt; &lt;context id=&quot;default&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--jdbc的数据库连接 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://127.0.0.1:3307/mls&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver &gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类 targetPackage 指定生成的model生成所在的包名 targetProject 指定在该项目下所在的路径 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.leida.model&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- 是否对model添加 构造函数 --&gt; &lt;property name=&quot;constructorBased&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;!-- 建立的Model对象是否 不可改变 即生成的Model对象不会有 setter方法，只有构造方法 --&gt; &lt;property name=&quot;immutable&quot; value=&quot;true&quot;/&gt; &lt;!-- 给Model添加一个父类 --&gt;&lt;!-- &lt;property name=&quot;rootClass&quot; value=&quot;com.foo.louis.Hello&quot;/&gt;--&gt; &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.leida.mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码 type=&quot;ANNOTATEDMAPPER&quot;,生成Java Model 和基于注解的Mapper对象 type=&quot;MIXEDMAPPER&quot;,生成基于注解的Java Model 和相应的Mapper对象 type=&quot;XMLMAPPER&quot;,生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;javaClientGenerator targetPackage=&quot;com.leida.mapper&quot; targetProject=&quot;src/main/java&quot; type=&quot;MIXEDMAPPER&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;&quot;/&gt; &lt;!-- 定义Maper.java 源代码中的ByExample() 方法的可视性，可选的值有： public; private; protected; default 注意：如果 targetRuntime=&quot;MyBatis3&quot;,此参数被忽略 --&gt; &lt;property name=&quot;exampleMethodVisibility&quot; value=&quot;&quot;/&gt; &lt;!-- 方法名计数器 Important note: this property is ignored if the target runtime is MyBatis3. --&gt; &lt;property name=&quot;methodNameCalculator&quot; value=&quot;&quot;/&gt; &lt;!-- 为生成的接口添加父接口 --&gt; &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName=&quot;test&quot; domainObjectName=&quot;Test&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 在pom.xml中添加自动生成代码的插件，在build中添加如下代码 1234567891011121314&lt;plugins&gt; &lt;!--mybatis代码自动生成插件--&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;!--配置文件位置--&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; 在maven中generate生成代码，会生成model的类和接口和mapper 添加controller包，添加controller 123456789101112131415161718package com.leida.controller;import com.leida.service.TestDataService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class TestController &#123; @Autowired private TestDataService testDataService; @GetMapping(&quot;/testData&quot;) public Object testData () &#123; return testDataService.getAllTestData(); &#125;&#125; 添加service包，里面添加接口和impl包，impl包中添加实现接口的类 1234567891011#接口package com.leida.service;import com.leida.model.Test;import java.util.List;public interface TestDataService &#123; public List&lt;Test&gt; getAllTestData();&#125; 实现上面接口的类1234567891011121314151617181920package com.leida.service.impl;import com.leida.mapper.TestMapper;import com.leida.model.Test;import com.leida.service.TestDataService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class TestDataServiceImpl implements TestDataService &#123; @Autowired private TestMapper testMapper; @Override public List&lt;Test&gt; getAllTestData() &#123; return testMapper.getAllData(); &#125;&#125; Mapper中添加底层方法 1List&lt;Test&gt; getAllData(); 编写TestMapper.xml，与Mapper.class中的方法名相对应 1234567891011&lt;!-- 查询所有数据--&gt; &lt;select id=&quot;getAllData&quot; resultMap=&quot;BaseResultMap&quot;&gt; &lt;!-- WARNING - @mbg.generated This element is automatically generated by MyBatis Generator, do not modify. --&gt; select * from test &lt;/select&gt;&lt;/mapper&gt; 测试还需要在pom.xml中，plugins下面添加如下配置，主要是第一个，否则xml无法编译进文件夹 123456789101112131415161718192021222324252627&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;!-- 开启过滤，用指定的参数替换directory下的文件中的参数 --&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt; **/*.java &lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt;&lt;/resources&gt; 集成jsp pom.xml需要额外这些依赖，在dependencies中 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 测试的起步依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 使用jsp引擎，springboot内置的tomcat没有此依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 添加servlet依赖模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- 添加jstl标签库依赖模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--添加tomcat依赖模块.--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; resources中的application.properties 1234567server.port=8080#上下文server.servlet.context-path=/mls#jsp访问路径spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp main下面建webapp/WEB-INF，下面建jsp文件 controller中建jspcontroller 123456789101112package com.leida.springboot.mls.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class JSPController &#123; @GetMapping(&quot;/&quot;) public String login()&#123; return &quot;index&quot;; &#125;&#125;","categories":[],"tags":[]},{"title":"有符号数与无符号数运算坑点","slug":"cpp0","date":"2019-09-17T06:51:56.629Z","updated":"2019-11-18T09:13:17.218Z","comments":true,"path":"2019/09/17/cpp0/","link":"","permalink":"http://curiousLei.github.io/2019/09/17/cpp0/","excerpt":"","text":"本篇博客来源于我在leetcode上遇到过的一个bug，当我按照如下所示循环条件时12//vector&lt;int&gt; nums;for(k=0;k&lt;nums.size()-2;k++) 输入的nums为空数组的情况下，按照常理nums.size()-2相当于0-2=-2，但是事违人愿，出现了如下报错1Line 923: Char 34: runtime error: reference binding to null pointer of type &apos;value_type&apos; (stl_vector.h) 原因是：vector::size返回unsigned integral类型，即无符号整形，又由于无符号数与有符号数运算时，会默认将有符号数当做无符号数来处理，下面举例说明 -2在16位机内存中存储形式是1111111111111110，即有符号数-2的补码形式，若该补码当成无符号数来处理，则表示十进制的65534，一个很大的数，32位或64位也以此类推，总之0-2的结果也就不等于-2了。如下代码可以输出这个很大的数12345678#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; nums; cout&lt;&lt;nums.size()-1&lt;&lt;endl; return 0;&#125; 输出结果为18446744073709551615，该数值取决于电脑无符号整数的位数。 当然，把-2去掉之后，便不会报错，因为直接将nums.size()当成0来处理 无符号数与有符号数的区别 无符号类型能保存2倍于有符号类型的数据，因为腾出来一个符号位 感觉这是c++编程中一大坑点，需要多多注意","categories":[],"tags":[]},{"title":"docker相关命令总结","slug":"dockerCommands","date":"2019-07-10T01:41:15.879Z","updated":"2019-11-18T09:18:56.113Z","comments":true,"path":"2019/07/10/dockerCommands/","link":"","permalink":"http://curiousLei.github.io/2019/07/10/dockerCommands/","excerpt":"","text":"启动容器 1docker run --name tomcat --net=host -d tomcat:latest docker容器开启一个终端 1docker exec -it testv4 /bin/bash docker私有网络创建容器 1docker run --name voipBridge -e TZ=&quot;Asia/Shanghai&quot; --cap-add=NET_ADMIN --mount src=voip,dst=/voip --network=mynet --ip 172.18.12.2 -p 8081:8081 -p 8082:8082 -p 7443:7443 -p 5090:5090 -p 25060:25060 -p 25061:25061 -p 5061:5061 -p 5066:5066 -p 3306:3306 -p 8021:8021 -p 5070:5070 -p 444:443 -p 81:80 -p 8443:8443 -p 5070:5070/udp -p 5090:5090/udp -p 15060:15060/udp -p 1337:1337/udp -itd centos:6.10 /bin/bash docker开启一个终端 1docker exec -it testv4 /bin/bash 查看正在监听的端口 1netstat -nltp docker镜像导入导出两种方法不可混用 12345docker save ubuntu:load&gt;/root/ubuntu.tardocker load&lt;ubuntu.tardocker export 98ca36&gt; ubuntu.tarcat ubuntu.tar | sudo docker import - ubuntu:import docker 运行mysql容器 1docker run --name mysql4 -e MYSQL_ROOT_PASSWORD=1234567 -d -P mysql docker 挂载volume 1docker run --name mysql4 -e MYSQL_ROOT_PASSWORD=1234567 --mount src=mydata,dst=/var/lib/mysql -d -P mysql docker registry获取存放镜像信息 12curl http://127.0.0.1:5000/v2/_catalogcurl http://127.0.0.1:5000/v2/centos/tags/list docker使用entrypoint时，首行一定要加#!/bin/bash，末尾行一定要加tail -f docker运行registry命令 1docker run --name registry --restart=always --mount src=myregistry,dst=/var/lib/registry -p 5000:5000 -d registry:latest docker容器内外拷贝 1docker cp httpd.conf f1322f792d36:/usr/local/apache2/conf/","categories":[],"tags":[]},{"title":"vagrant相关","slug":"vagrant","date":"2019-07-09T13:15:27.250Z","updated":"2019-07-09T13:16:04.125Z","comments":true,"path":"2019/07/09/vagrant/","link":"","permalink":"http://curiousLei.github.io/2019/07/09/vagrant/","excerpt":"","text":"无法挂载共享目录，报错如下 Vagrant was unable to mount VirtualBox shared folders. This is usuallybecause the filesystem &quot;vboxsf&quot; is not available. This filesystem ismade available via the VirtualBox Guest Additions and kernel module.Please verify that these guest additions are properly installed in theguest. This is not a bug in Vagrant and is usually caused by a faultyVagrant box. For context, the command attempted was:mount -t vboxsf -o uid=1000,gid=1000 vagrant_app /vagrant/appThe error output from the command was:mount: unknown filesystem type &apos;vboxsf&apos; 解决办法点击此处 vgrant常用命令 $ vagrant init # 初始化$ vagrant up # 启动虚拟机$ vagrant halt # 关闭虚拟机$ vagrant reload # 重启虚拟机$ vagrant ssh # SSH 至虚拟机$ vagrant suspend # 挂起虚拟机$ vagrant resume # 唤醒虚拟机$ vagrant status # 查看虚拟机运行状态$ vagrant destroy # 销毁当前虚拟机$ vagrant box list # 查看本地box列表$ vagrant box add # 添加box到列表$ vagrant box remove # 从box列表移除","categories":[],"tags":[]},{"title":"git常用命令总结","slug":"gitCommands","date":"2019-07-09T13:12:35.355Z","updated":"2019-07-15T13:52:47.503Z","comments":true,"path":"2019/07/09/gitCommands/","link":"","permalink":"http://curiousLei.github.io/2019/07/09/gitCommands/","excerpt":"","text":"你的初始化例子1[rectangle setX: 10 y: 10 width: 20 height: 20]; 我的 查看客户端用户名邮箱 12git config user.namegit config user.email 修改用户名密码 12git config --global user.name &quot;leida&quot;git config --global user.email &quot;leida@bjfu.edu.cn&quot; 创建仓库后初始化 123456echo &quot;###&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https:....git push -u origin master git clone之后会自动建立remote 同一行文本被不同分支修改过，才会有冲突，只有一个人修改，则不存在冲突，会直接覆盖 1git push -u origin dev 表示将当前分支推送到远程dev分支上，-u表示建立关联，之后就只需要git push 就行 出现refuseing to merge unrelated histories，按如下解决 1git pull origin master --allow-unrelated-histories 关联远程分支 1git push --set-upstream origin hexo","categories":[],"tags":[]},{"title":"软著流程记录","slug":"ruanzhuRecord","date":"2019-07-05T13:05:57.909Z","updated":"2019-06-18T09:17:43.649Z","comments":true,"path":"2019/07/05/ruanzhuRecord/","link":"","permalink":"http://curiousLei.github.io/2019/07/05/ruanzhuRecord/","excerpt":"","text":"软著申请流程1.准备材料http://yewu.bjppb.gov.cn/bjppb/member/login.do?ut=cpy_soft账户：北京林业大学密码：12345678填写申报表格（必须认真填写）2.导师签字：申请表、用印批办单、知识产权承诺书3.张平盖章：用印批办单、知识产权承诺书4.科技处签字：310找老师，说申请软著，就有人说怎么弄。5.学校盖章：红楼310找老师签完字；去101盖学校公章，拿学校法人复印件。6.交付版权局：北京市政服务中心，一层大厅。学校盖章的：一份网上打印的申请书、法人复印件、两个声明。院里盖章的：用印批办单，交给顾京的申请书。 问题及解决方法1.打印申请表 填表的时候，在开发者工具中把IE的内核版本调低（仿真一栏中，文档模式和用户代理字符串都改成IE7）即可正常填写； 打印的时候，同样把IE的内核版本调低（降成IE7貌似还不够，试一下全部调成IE5），即可打印成pdf下载下来，然后检查一下，看看有没有错版或者多页少页（当然也可以直接打印成纸质版）。 2.文档格式 在线填报网站上的“申报须知”（填表的前一步）中有格式说明，仔细读一读，严格按照它的来写，就基本没问题了。两份文档（软件说明和源程序）的格式要求如下： 3、源程序 1份（注：不要装订）（1）按源程序前30页和源程序最后30页提交，第1页为起始页，第60页为结束页。不足60页的需要提交全部源程序。每页不少于50行（结束页可少于50行）。 在每页的右上角通过电脑以阿拉伯数字连续标注页码。除第60页外，每页不能出现半页。源程序须添加页眉，页眉处务必写清软件的名称（与全称或简称一致）及版本号。（2）源程序中作者应是著作权人。（3）源程序中日期须在开发完成日期之前。（4）源程序中的名称须与申请表中全称或简称一致。4、文档 1份（注：不要装订）（1）设计说明书、用户手册、操作手册、使用说明等（任选一种）。（2）按文档前30页和文档最后30页提交。第1页为起始页，第60页为结束页。不足60页的需要提交全部文档。每页不少于30行（页中有插图或结束页可少于30行）。在正文的右上角通过电脑以阿拉伯数字标注连续页码。除第60页外，每页不能出现半页。文档须添加页眉，页眉处务必写清软件的名称（与全称或简称一致）及版本号。文档可以不要封面，但必须在文档的正文第一页标题中写清楚文档的种类。（比如：微软操作系统使用说明书；微软操作系统设计说明书；微软操作系统用户手册；微软操作系统操作手册）。（3）文档中作者应是著作权人。（4）文档中的日期须在软件开发完成日期之前。（5）文档中的名称须与申请表中全称或简称一致。 申请表中软件名称尽量写xxx平台，xxx软件，xxx系统，否则可能不给过；所有材料中软件名字要统一。 3.市政厅办理注意 身份证复印件正反面在同一页，单面打印； 如果被指出文档格式问题，不用慌，可以想办法当场改一改，市政厅楼上可以打印；但如果申请表有问题，就必须再跑一趟了，因为要重新盖章（拿着新的申请表直接去红楼101盖章即可，旧的会被老师撕掉）； 如果工作人员建议你直接去版权中心办软著，不用理她，因为版权中心的电话永远打不通，去了之后还会发现那边要的申请表格式和咱们的不一样（要带条码的那种）。","categories":[],"tags":[]},{"title":"linux常用命令总结","slug":"linux常用命令总结","date":"2019-07-05T13:05:57.892Z","updated":"2019-11-18T09:18:49.456Z","comments":true,"path":"2019/07/05/linux常用命令总结/","link":"","permalink":"http://curiousLei.github.io/2019/07/05/linux常用命令总结/","excerpt":"","text":"根目录下查找名称前缀为my的文件(文件夹) 1find / -name &apos;my&apos; linux向linux复制文件，-P（大写P）表示端口号（默认22） 1scp -P 2233 passwordModify_encrypt.php root@118.192.66.57:/var/www/opensips-cp/web/ ssh远程登录（小写p） 1ssh -p 2233 root@118.192.66.57 windows下向linux拷贝文件 1pscp -l leida file.zip 192.168.50.24:/home/leida/ 查找目录下包含某一字段的文件 1grep &quot;client&quot; ./ -nr iptables添加开放端口 123456789iptables -A INPUT -p tcp --dport 80 -j ACCEPTservice iptables saveservice iptables restart-A 指append添加规则(末尾)，-I指插入，-D指删除INPUT指输入数据包，相对的是OUTPUT--dport指目的端口，相对的是sport源端口-j ACCEPT 表示动作，相对的是DROP注意：新添加的规则要插入到 RH-Firewall-1-INPUT 之前才能生效，具体原因有待探究 ubuntu下卸载apache2 123456apt purge remove apache2apt purge remove apache2.2-commonapt autoremovefind /etc/ -name &quot;*apache*&quot; | xargs rm -rfrm -rf /var/www 查看linux版本 1234cat /etc/issue#适合所有版本系统lsb_release -a #适合所有版本cat /etc/redhat-release#这种方法只适合Redhat系的Linuxuname -a#查看系统内核版本 查看仓库包 1yum repolist all centos7加载本地光盘yum源 1234567891011121314mount /dev/cdrom/ /mnt/cd /etc/mv yum.repos.d yum.repos.d.bakmkdir yum.repos.dvim yum.repos.d/Centos-Local.repo[Local]name=Local Yumbaseurl=file:///mnt/gpgcheck=0enabled=1yum clean yum makecache centos修改root密码https://blog.csdn.net/akipa11/article/details/81395386 nginx相关命令 123456/usr/local/nginx/sbin/nginx# 启动/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf# 检查配置是否正确/usr/local/nginx/sbin/nginx -s reload# 修改配置后使配置生效 centos7命令行和图形界面互相切换 1234vim /etc/inittabsystemctl get-default systemctl set-default multi-user.targetsystemctl set-default multi-user.target 创建多层文件夹 12mkdir -p demoCA/newcertstouch ./demoCA/index.txt ./demoCA/serial #创建多个文件 grep满足多个可选关键字 1grep -E &quot;me|data&quot; meDec.php grep排除字段 1grep -v &quot;message&quot; meDec.php 删除多级目录下同一格式的文件 1find ./ -name *.o -exec rm -rf &#123;&#125; \\; apache2加载php7.0 1234apt purge libapache2-mod-php7.0 libapache2-mod-phpapt install libapache2-mod-php7.0 libapache2-mod-phpa2enmod php7.0# 不是a2enmod php 为用户添加sudo 123chmod 640 /etc/sudoersleida ALL=(ALL) ALLchmod 440 /etc/sudoers 获取外网ip 1curl icanhazip.com 获取本机ip 1ip route get 8.8.8.8 | awk &apos;&#123;print $NF; exit&#125;&apos; docker开启一个终端 1docker exec -it testv4 /bin/bash 查看正在监听的端口 1netstat -nltp docker镜像导入导出两种方法不可混用 12345docker save ubuntu:load&gt;/root/ubuntu.tardocker load&lt;ubuntu.tardocker export 98ca36&gt; ubuntu.tarcat ubuntu.tar | sudo docker import - ubuntu:import docker 运行mysql容器 1docker run --name mysql4 -e MYSQL_ROOT_PASSWORD=1234567 -d -P mysql docker 挂载volume 1docker run --name mysql4 -e MYSQL_ROOT_PASSWORD=1234567 --mount src=mydata,dst=/var/lib/mysql -d -P mysql linux系统时间 123456781.date //查看本地2.hwclock --show //查看硬件的时间3.如果硬件的时间是对不上，那就对硬件的时间进行修改、4.hwclock --set --date &apos;2016-01-08 15:15:15&apos; //设置硬件时间5.hwclock --hctosys //设置系统时间和硬件时间同步6.clock -w //保存时钟7.最后在通过重启，init 6 （reboot） //重启后，查看系统时间是否真正生效 添加用户 12useradd leidapasswd leida 网卡未启动时，通过该命令来自动获取ip 1dhclient docker registry获取存放镜像信息 12curl http://127.0.0.1:5000/v2/_catalogcurl http://127.0.0.1:5000/v2/centos/tags/list daemon.json 12#里面不能写注释#客户端加上 &quot;insecure-registries&quot;: [ &quot;192.168.50.161:5000&quot;]才能通过http访问，否则需要配置https centos6更新yum源 12345678910111213141516171、备份cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d//CentOS-Base.repo.ori2、下载新的CentOS-Base.repo 到/etc/yum.repos.d/wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo# -O表示重命名3、清理 yum clean all4、更新缓存yum makecache#yum install tree -yyum update -y 删除mysql 1234567yum remove mysql mysql-server mysql-libs mysql-server; find / -name mysql 将找到的相关东西delete掉； rpm -qa|grep mysql(查询出来的东东yum remove掉) rpm -e mysql相关文件 centos下载service 1yum install initscripts -y centos下载telnet 12yum install xinetdyum install telnet yum下载crontab 1yum -y install vixie-cron docker使用entrypoint一定要加#!/bin/bash docker使用entrypoint 一定要加tail -f 刚开新虚拟机配置网络 123456789101112#网络配置文件：/etc/sysconfig/network-scripts/ifcfg-ens33#static assignmentNM_CONTROLLED=no #表示该接口将通过该配置文件进行设置，而不是通过网络管理器进行管理ONBOOT=yes #开机启动BOOTPROTO=static #静态IPIPADDR=192.168.50.161 #本机地址NETMASK=255.255.255.0 #子网掩码GATEWAY=192.168.50.1 #默认网关DNS1=180.76.76.76DNS2=8.8.8.8systemctl restart network 下载netstat 1yum -y install net-tools run.sh的执行路径是根目录，不是/root/ 查看当前文件夹下文件大小 1du -sh * vim相关命令 123456:set nu#显示行号:32,56d#删除上下行号之间的代码shift+G#跳到最后一行 firewall相关 123456#添加开放端口firewall-cmd --zone=public --add-port=80/tcp --permanent #查看所有打开的端口firewall-cmd --zone=public --list-ports#更新防火墙规则firewall-cmd --reload 选择时区1tzselect","categories":[],"tags":[]},{"title":"https搭建(自签名证书)","slug":"https搭建(自签署证书)","date":"2019-07-05T13:05:57.861Z","updated":"2019-07-05T13:42:34.459Z","comments":true,"path":"2019/07/05/https搭建(自签署证书)/","link":"","permalink":"http://curiousLei.github.io/2019/07/05/https搭建(自签署证书)/","excerpt":"","text":"上一篇博客探究了https（ssl）的原理，为了贯彻理论落实于实践的宗旨，本文将记录我搭建https的实操流程，使用Apache2+ubuntu+opensssl 1.使用自签证书配置https一般来讲，正式的上线项目都需要购买域名，并且向权威机构申请证书。但本次工作属于测试环境，所以一切从简，我们使用openssl工具生自签名的CA证书以及服务器证书，来搭建https。具体步骤如下： （1）安装apache2、openssl(ubuntu16.04)安装过程此处不做赘述，很简单。Apache2安装完成并启动后，通过http://ipaddress 来测试，如下图所示，说明安装成功 （2）制作证书生成自签CA证书 生成CA私钥 openssl genrsa -out ca.key 2048 生成CA证书 openssl req -new -x509 -days 3650 -key ca.key -out ca.crt -config /etc/ssl/openssl.cnf openssl.cnf的路径注意填对。最后在当前目录下生成的ca.key即为CA私钥，ca.crt即为CA证书（包含CA公钥） 生成服务器证书 生成服务器私钥 openssl genrsa -out server.key 2048 生成服务器签署申请文件 openssl req -new -out server.csr -key server.key -config /etc/ssl/openssl.cnf 需要填写服务器信息，如实填写即可。需要注意Common Name 需要与openssl.cnf 中配置的域名相对应（alt_names），否则客户端无法验证。该命令最后生成的server.csr即为申请文件。openssl.cnf的具体配置见下文。 在签署证书之前需要确认openssl.cnf中的配置，如下所示： #根据实际情况修改，将match改成optional，否则ca.crt必须与server.csr中的各个字段值一致才能签署[ policy_match ]countryName = optionalstateOrProvinceName = optionalorganizationName = optionalorganizationalUnitName = optionalcommonName = suppliedemailAddress = optional# 确保req下存在以下2行（默认第一行是有的，第2行被注释了）[ req ]distinguished_name = req_distinguished_namereq_extensions = v3_req# 确保req_distinguished_name下没有 0.xxx 的标签，有的话把0.xxx的0. 去掉[ req_distinguished_name ]countryName = Country Name (2 letter code)countryName_default = XXcountryName_min = 2countryName_max = 2stateOrProvinceName = State or Province Name (full name)localityName = Locality Name (eg, city)localityName_default = Default CityorganizationName = Organization Name (eg, company)organizationName_default = Default Company LtdorganizationalUnitName = Organizational Unit Name (eg, section)commonName = Common Name (eg, your name or your server\\&apos;s hostname)commonName_max = 64emailAddress = Email AddressemailAddress_max = 64#添加一行subjectAltName=@alt_names[ v3_req ]# Extensions to add to a certificate requestbasicConstraints = CA:FALSEkeyUsage = nonRepudiation, digitalSignature, keyEnciphermentsubjectAltName=@alt_names#新增alt_names,注意括号前后的空格，DNS.x 的数量可以自己加#如果没有IP这一项，浏览器使用IP访问时验证无法通过[ alt_names ]IP.1 = 192.168.50.115DNS.1 = dfe.leida.orgDNS.2 = ex.abcexpale.net 使用CA证书和私钥签署服务器证书 openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key -extensions v3_req -config /etc/ssl/openssl.cnf 直接运行该签署命令，会报错，提示缺少某些文件和目录。在当前目录下把相应的文件及文件夹创建上即可解决，如下 mkdir -p demoCA/newcertstouch ./demoCA/index.txt ./demoCA/serialecho &quot;01&quot;&gt;&gt; ./demoCA/serial 创建完毕后，运行签署命令即可完成服务器证书的制作。当前目录下生成的server.crt即为服务器证书，server.key为服务器私钥 （3）配置apache2 启用ssl模块(此处可使用a2enmod命令) a2enmod ssl 启用ssl站点 a2ensite default-ssl 加入监听端口443(因为https默认采用443端口，有别于http的80) listen 80 443# /etc/apache2/ports.conf中修改成如上所示即可 配置证书以及私钥的路径 SSLCertificateFile /etc/ssl/certs/server.crtSSLCertificateKeyFile /etc/ssl/private/server.key# 在/etc/apache2/sites-available/default-ssl.conf中修改如上参数，确认证书和私钥的路径正确无误 重启apache2，搞定！ 2.使用浏览器测试https上述的制作证书步骤，已经是我测试结束、爬完坑后的正确教程，下文则是填坑记录。 实际上，我一开始按照网上的方法搭建完https后，出现过一些问题。使用浏览器访问https://ipaddress 会跳出如下提示界面实际上此时浏览器已获取到服务器证书server.crt，只是由于某些原因无法验证它。若选择高级选项中的“继续浏览”时，同样可以正常跳转至对应的页面，这时相当于强行让浏览器接受该证书，同时接受服务器公钥。在测试环境下，这样完全OK。但是，强迫症的我还是想让导航栏上出现安全的小锁，红叉叉看着很难受啊。 下面总结记录一下使用浏览器（chrome）测试的过程中遇到的问题以及解决方法 （1）客户端缺少CA证书点击导航栏左侧的感叹号，查看证书，如下图所示此时浏览器已获取到server.crt，由于其对应的CA证书不存在于“受信任的根证书机构”中，所以无法验证server.crt 我们需要将CA证书（上文使用OpenSSL生成的ca.crt）安装至客户端系统中的“受信任的根证书机构”中，保证浏览器可通过此CA证书来验证服务器证书server.crt。安装过程很简单，双击如下所示安装即可 安装结束后，重启浏览器，再次打开证书，如下所示 此时浏览器已经可以使用ca证书来验证server.crt，已完成了很重要的一步，但我的chrome浏览器依然没有出现小锁 （2）缺少使用者备用名称完成上一步后，浏览器的导航栏依然显示不安全，我打开开发者工具，查看security得知，是服务器证书缺少“使用者备用名称”所导致，如下图所示。如何解决这个问题，我参考了这个博客（http://blog.51cto.com/colinzhouyj/1566438 ），即修改openssl.cnf的部分配置，前文“制作证书”步骤中已经整合过此处的配置内容。修改完，重新签署证书，重启apache2，再次运行，Subject Alternative Name missing的问题解决。 （3）IP验证不通过在上一步操作中，我添加完几条DNS之后，发现chrome依然报错，如下图所示我用的是虚拟机环境，没有域名解析，而是直接通过IP来访问站点的，又由于证书中不存在IP信息，是无法跟URL中的IP进行比对的，因此浏览器无法通过证书验证。该问题有两个解决方法 （1）在证书中添加IP地址。在openssl.cnf中配置使用者可选名称时，添加一条IP地址，即可保证浏览器通过对IP的验证，重新签署配置运行后，结果如下 打开证书，使用者可用名称字段如下 （2）使用域名访问。在客户机的host文件中配置域名与IP的映射，直接使用域名来访问站点（证书中包含域名），即可通过验证，如下所示 使用这两种方法的其中一种，迟迟不肯露面的小锁终于出现了，打开security也是一片绿色，大功告成。但是，要注意一点，不同浏览器对于证书的验证方式可能存在差异。按照我的操作，firefox依然无法验证，暂时没细究，但chrome和edge浏览器都可以完美运行。","categories":[],"tags":[]},{"title":"https原理总结","slug":"https原理总结","date":"2019-07-05T13:05:57.844Z","updated":"2019-07-05T13:42:30.230Z","comments":true,"path":"2019/07/05/https原理总结/","link":"","permalink":"http://curiousLei.github.io/2019/07/05/https原理总结/","excerpt":"","text":"最近在公司项目的服务器上做一些内部接口，要求使用https，于是花时间研究了一波。我们熟知的http在传输时未对数据进行加密，在传输一些敏感信息时存在着不小的安全隐患。因此，https在http的基础上加上了SSL（Secure Sockets Layer）加密，以保障数据的安全传输。如今使用的TLS实际上是SSL的升级版本。具体有关https的概念可参考百科https介绍 1.https原理探究https的保障信息安全的机制，其实用一句话就能概括：client与server通过非对称加密来协商一个对称秘钥，然后CS两端使用该对称秘钥来进行数据的加密解密，完成数据交互。所以数据传输时，实际上走的是对称加密。当然理解这句话前提，需要明白对称和非对称加密的原理，本文不做讨论。 原理概况SSL加密机制的大致过程： client发送请求 server返回证书 client验证并取出证书中的公钥 client生成随机数，并使用服务器公钥将其加密，把得到的密文发送给server server使用私钥解密，得到随机数 两端各自通过随机数生成对称秘钥，协商完成 数字证书与数字签名在详细介绍握手环节之前，我想先说说数字数字证书的起因及原理，数字证书是整个SSL加密的核心与纽带。首先，在使用非对称加密传输之前，客户端需要获取服务器公钥，这里存在一种攻击方式，即中间方使用自己的公钥替换服务器的公钥发送给客户端，再通过自己的私钥获取客户端传来的非对称加密内容，从而实现篡改以及窃听。为了方便理解，网上有一张图我直接拿来用了，如下所示。为了防止获取公钥过程遭到第三方的掉包等之类的破坏，于是便有了证书机制，下图为服务器证书的签署以及验证的大致流程。 证书包含三部分内容 证书内容（服务器公钥、服务器信息等） 加密算法（加密算法、哈希算法） 密文（使用哈希算法计算证书内容得到哈希摘要，再使用CA私钥加密该摘要即得到密文，该过程称为数字签名） 验证数字证书 客户端验证服务器证书时，需要获取到你的上一级CA证书，从而得到取CA公钥，使用CA公钥对证书中的密文解密得到哈希摘要，同时客户端使用同样的哈希算法对服务器证书内容计算得到另一个哈希摘要，若这两个摘要相等，则证明证书合法。 上述的哈希签名也称为数字指纹法，该方法的精髓在于，相同的明文通过哈希计算得到的摘要，一定是相同的，而只要两份明文只要有一丝丝区别，其对应的哈希值也是不同的。因此，若第三方替换了证书中的公钥，根据证书内容计算出的新的摘要一定与密文中的摘要有所差异的，故可以轻松地判断证书不合法。 疑问 （1）既然是使用上级CA证书来验证服务器证书，那如何证明上级CA证书的合法性？ 这涉及到一个证书信任链的问题。上级证书通过更高一级的CA根证书来确定其合法性，这是一个递归向上的过程，直到最顶层根证书。顶层CA根证书是整个安全体系的根本。 （2）前文提到的攻击方式，只替换公钥显然是不行，那如果第三方把整个证书都替换成自己的证书（因为CA机构可以给任何人签名，黑客也可以），这样的话客户端的验证是不是可以通过？ 答案当然是否定的，很简单，因为证书内容里的服务器信息是唯一的、不可复制的，例如域名，若替换整个证书，域名也会变成黑客自己的域名，浏览器不会接受域名和请求内容不匹配的证书。比如说，浏览器请求了 baidu.com，结果返回了个google.com的证书，毫无疑问会立即排除掉。 保证了服务器公钥安全抵达客户端手中，后续的对话秘钥的协商便也能顺理成章地进行。因此https所采用的SSL机制是绝对安全的，几乎没有人能够破解。当然，有得必有失，https花费的开销也远高于http。 SSL握手过程 https握手原理图 理解了上文所讲的证书机制，其实SSL加密机制也基本容易理解了，下面细究一下SSL握手过程，此处结合上方交互原理图进行分析（1） Client Helllo。客户端发送初次请求，请求内容包含版本信息，加密套件候选列表，压缩算法候选列表，随机数random_1，扩展字段等信息，以明文传输； （2）服务器选择客户端支持的加密套件、压缩算法、协议版本等，生成随机数random_2； （3）服务器将上述算法以及随机数等发送给客户端； （4）服务器发送服务器数字证书； （5）客户端接收服务器选择的算法以及随机数等，验证数字证书。若证书验证通过，或者用户接受了不可信证书，客户端获取服务器公钥，同时会生成随机数random_3，并使用服务器公钥加密该随机数得到密文； （6）客户端将第五步得到的密文传给服务器，由于公钥加密的内容只能使用私钥解开，所以random_3无法被窃听； （7）Change cipher Spec。客户端通知服务器协商完成； 此时客户端已存有三个随机数random_1、random_2和random_3，前两个是可以被截获的，第三个是私密的，根据这三者可计算得出对话秘钥，即enc_key=Fuc(random_1, random_2, random_3) （8）客户端结合之前所有通信参数的 hash 值与其它相关信息生成一段数据，并使用对话秘钥enc_key和算法将其加密，得到密文encrypted_handshake_message，将其发送给服务器进行验证； （9）服务器使用私钥解密第六步得到的密文，得到随机数random_3，此时服务器也拥有了三个随机数random_1、random_2和random_3，同样可计算出对话秘钥enc_key，至此双方共享对称加密秘钥的目的已达成；计算之前所有接收信息的 hash 值，然后解密客户端发送的 encrypted_handshake_message，验证数据和密钥正确性; （10）类似7和8，服务器通知客户端协商完成，同时计算发送encrypted_handshake_message。客户端以同样的方式验证encrypted_handshake_message，握手完成。 完成握手之后，服务器和客户端都使用相同的对话秘钥enc_key，对消息内容进行加密，实现安全通信。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-07-05T13:05:57.835Z","updated":"2018-07-09T06:28:05.440Z","comments":true,"path":"2019/07/05/hello-world/","link":"","permalink":"http://curiousLei.github.io/2019/07/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"用户评论情感极性判别","slug":"用户评论情感极性判别","date":"2018-07-09T10:34:52.000Z","updated":"2018-07-09T10:35:12.340Z","comments":true,"path":"2018/07/09/用户评论情感极性判别/","link":"","permalink":"http://curiousLei.github.io/2018/07/09/用户评论情感极性判别/","excerpt":"本文章介绍百度点石平台上的一个训练赛的赛题代码，赛题是包括用户评论文字的情感判别的分类问题，赛题链接戳此处 数据预处理 使用测试数据和训练数据生成语料库 import numpy as npimport jiebaimport codecs# 该函数作用是读取文件def load_data(file_path): data_set = [] with open(file_path, &apos;r&apos;) as lines: for line in lines: line=line.strip() values=line.split(&quot;\\t&quot;) data_set.append(values) np.array(data_set) # print(data_set[0]) return data_setdataAll=load_data(&apos;data_train.csv&apos;)dataTest=load_data(&apos;data_test.csv&apos;)csvfile = codecs.open(&quot;fenci_result.csv&quot;, &apos;w&apos;, &apos;utf-8&apos;)#f=open(&apos;fenci_result.txt&apos;,&apos;a&apos;)for item in dataAll: seg_list=jieba.cut(item[2])#使用结巴分词 csvfile.write(&quot; &quot;.join(seg_list))#以空格隔开把分好的词写入文件，形成语料#f.close()for item in dataTest: seg_list=jieba.cut(item[-1]) csvfile.write(&quot; &quot;.join(seg_list))","text":"本文章介绍百度点石平台上的一个训练赛的赛题代码，赛题是包括用户评论文字的情感判别的分类问题，赛题链接戳此处 数据预处理 使用测试数据和训练数据生成语料库 import numpy as npimport jiebaimport codecs# 该函数作用是读取文件def load_data(file_path): data_set = [] with open(file_path, &apos;r&apos;) as lines: for line in lines: line=line.strip() values=line.split(&quot;\\t&quot;) data_set.append(values) np.array(data_set) # print(data_set[0]) return data_setdataAll=load_data(&apos;data_train.csv&apos;)dataTest=load_data(&apos;data_test.csv&apos;)csvfile = codecs.open(&quot;fenci_result.csv&quot;, &apos;w&apos;, &apos;utf-8&apos;)#f=open(&apos;fenci_result.txt&apos;,&apos;a&apos;)for item in dataAll: seg_list=jieba.cut(item[2])#使用结巴分词 csvfile.write(&quot; &quot;.join(seg_list))#以空格隔开把分好的词写入文件，形成语料#f.close()for item in dataTest: seg_list=jieba.cut(item[-1]) csvfile.write(&quot; &quot;.join(seg_list)) 利用语料库，使用word2vec工具，生成可备用的模型，用于将句子转化为向量 from gensim.models import word2vecimport logginglogging.basicConfig(format = &apos;%(asctime)s : %(levelname)s : %(message)s&apos;, level = logging.INFO)sentences = word2vec.Text8Corpus(&quot;fenci_result.csv&quot;) # 加载语料model = word2vec.Word2Vec(sentences, size = 400) # 训练skip-gram模型# 保存模型，以便重用model.save(&quot;corpus.model&quot;)model.wv.save_word2vec_format(&quot;corpus.model.bin&quot;, binary = True) 数据训练与测试 感觉训练方式很简陋，有待改善 #本程序用来测试模型#coding=utf-8 import reimport numpy as npimport jiebafrom gensim.models import word2vecimport loggingimport codecsfrom sklearn.decomposition import PCAfrom sklearn.model_selection import train_test_splitfrom sklearn import svmfrom sklearn.metrics import accuracy_score,confusion_matrix, f1_score, precision_score, recall_score, \\ roc_curve # 导入指标库import prettytable # 导入表格库# 该函数作用是读取文件def load_data(file_path): data_set = [] with open(file_path, &apos;r&apos;) as lines: for line in lines: line=line.strip() values=line.split(&quot;\\t&quot;) data_set.append(values) np.array(data_set) # print(data_set[0]) return data_set#写文件def write_result(array, outpuFilePath): with open(outpuFilePath, &apos;w&apos;) as output_file: for i in range(len(array)): output_file.write(&quot;%d,%d\\n&quot; % (i+1,array[i]))#将句子转化为向量def getWordVecs(wordList): vecs = [] for word in wordList: word = word.strip() try: vecs.append(model[word]) except KeyError: continue # vecs = np.concatenate(vecs) return np.array(vecs, dtype = &apos;float&apos;)model = word2vec.KeyedVectors.load_word2vec_format(&quot;corpus.model.bin&quot;, binary = True)# segList=jieba.cut(&apos;烤鸭还是不错的，别的菜没什么特殊的&apos;)# resultList = getWordVecs(segList)# print(sum(np.array(resultList))/2)dataAll=load_data(&apos;data_train.csv&apos;)X=[]y=[]dataAll=np.array(dataAll[:1500])for item in dataAll: #temp=int(item[-1]) #y.append(temp if temp!=0 else 1)#把0都替换成1，先对2和1进行分类 y.append(int(item[-1])) segList=jieba.cut(item[2]) vecList=getWordVecs(segList) if len(vecList) != 0: X.append(sum(np.array(vecList))/len(vecList))X=X[:]x_train=np.array(X)y_train=np.array(y)print(x_train)print(y_train)# x_train = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2], [2, 1], [3, 2]])# print(x_train)# 使用sklearn的PCA进行维度转换model_pca = PCA(n_components=0.95) # 建立PCA模型对象model_pca.fit(x_train) # 将数据集输入模型#model_pca.transform(x_train) # 对数据集进行转换映射newX=model_pca.fit_transform(x_train)#进行转换映射，并将转换后的赋给newXcomponents = model_pca.components_ # 获得转换后的所有主成分(不明白什么意思)components_var = model_pca.explained_variance_ # 获得各主成分的方差components_var_ratio = model_pca.explained_variance_ratio_ # 获得各主成分的方差占比print(&quot;\\n主成分分析：&quot;)print (components) # 打印输出前2个主成分print (len(components_var)) # 打印输出所有主成分的方差print (components_var_ratio) # 打印输出所有主成分的方差占比print(len(newX))print(len(newX[0]))X_train, X_test, y_train, y_test = train_test_split(newX, y_train, test_size=.3, random_state=0)clf = svm.SVC(C=1, kernel=&apos;linear&apos;,decision_function_shape=&apos;ovr&apos;)clf.fit(X_train, y_train)y_hat=clf.predict(X_test)##评价指标accuracy_s = accuracy_score(y_test, y_hat) # 准确率precision_s = precision_score(y_test, y_hat, average=&apos;macro&apos;) # 精确度recall_s = recall_score(y_test, y_hat, average=&apos;macro&apos;) # 召回率f1_s = f1_score(y_test, y_hat, average=&apos;weighted&apos;) # F1得分print(&apos;Accuracy:&apos;)print(accuracy_s)print(&apos;Precision:&apos;)print(precision_s)print(&apos;Recall:&apos;)print(recall_s)print(&apos;f-measure:&apos;)print(f1_s)##混淆矩阵confusion_m = confusion_matrix(y_test,y_hat) # 获得混淆矩阵confusion_matrix_table = prettytable.PrettyTable() # 创建表格实例confusion_matrix_table.add_row(confusion_m[0, :]) # 增加第一行数据confusion_matrix_table.add_row(confusion_m[1, :]) # 增加第二行数据confusion_matrix_table.add_row(confusion_m[2, :]) # 增加第三行数据print (&apos;confusion matrix&apos;)print (confusion_matrix_table) # 打印输出混淆矩阵write_result(y_hat,&apos;print.csv&apos;) 预测阶段 使用所有训练数据训练模型并对test数据进行预测 #本程序用来进行预测#coding=utf-8 import reimport numpy as npimport jiebafrom gensim.models import word2vecimport loggingimport codecsfrom sklearn.decomposition import PCAfrom sklearn.model_selection import train_test_splitfrom sklearn import svm# 该函数作用是读取文件def load_data(file_path): data_set = [] with open(file_path, &apos;r&apos;) as lines: for line in lines: line=line.strip() values=line.split(&apos;\\t&apos;) data_set.append(values) np.array(data_set) # print(data_set[0]) return data_set#写文件def write_result(array, outpuFilePath): with open(outpuFilePath, &apos;w&apos;) as output_file: for i in range(len(array)): output_file.write(&quot;%d,%d\\n&quot; % (i+1,array[i]))#将句子转化为向量def getWordVecs(wordList): vecs = [] for word in wordList: word = word.strip() try: vecs.append(model[word]) except KeyError: continue # vecs = np.concatenate(vecs) return np.array(vecs, dtype = &apos;float&apos;)#对预测数据进行处理def preDataHandle(): preData=load_data(&apos;data_test.csv&apos;) #exit(0) xPre=[] i=0 k=0 for item in preData: i+=1 s=&apos;&apos; for j in range(len(item)): if(j&gt;1): s=&quot;%s%s&quot;%(s,item[j]) segList=jieba.cut(s) vecList=getWordVecs(segList) if len(vecList) != 0: xPre.append(sum(np.array(vecList))/len(vecList)) else: k+=1 print(&apos;存在vecList长度为0的情况&apos;) print(item) x_pre=np.array(xPre) model_pca = PCA(n_components=factorNum) # 建立PCA模型对象 model_pca.fit(x_pre) # 将数据集输入模型 x_pre=model_pca.fit_transform(x_pre)#进行转换映射 return x_premodel = word2vec.KeyedVectors.load_word2vec_format(&quot;corpus.model.bin&quot;, binary = True)dataAll=load_data(&apos;data_train.csv&apos;)X=[]y=[]#dataAll=np.array(dataAll[:1500])for item in dataAll: print(item) y.append(int(item[-1])) segList=jieba.cut(item[2]) vecList=getWordVecs(segList) if len(vecList) != 0: X.append(sum(np.array(vecList))/len(vecList)) else: print(item)X=X[:]x_train=np.array(X)y_train=np.array(y)model_pca = PCA(n_components=0.95) # 建立PCA模型对象model_pca.fit(x_train) # 将数据集输入模型#model_pca.transform(x_train) # 对数据集进行转换映射newX=model_pca.fit_transform(x_train)#进行转换映射，并将转换后的赋给newXfactorNum=len(newX[0])clf = svm.SVC(C=1, kernel=&apos;linear&apos;,decision_function_shape=&apos;ovr&apos;)clf.fit(newX, y_train)x_pre=preDataHandle()y_pre=clf.predict(x_pre)write_result(y_pre,&apos;output.csv&apos;)print(&apos;Project has been finished successfully!&apos;) 比赛平台上计算出的结果f1-score为0.7249，很低，希望再接再厉","categories":[],"tags":[]},{"title":"Hello,Hexo!","slug":"Hello-Hexo","date":"2018-07-09T06:58:15.000Z","updated":"2019-12-05T08:07:44.480Z","comments":true,"path":"2018/07/09/Hello-Hexo/","link":"","permalink":"http://curiousLei.github.io/2018/07/09/Hello-Hexo/","excerpt":"常见命令12345678hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面（新建了一个md文件组,但目前不知道怎么用）hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本hexo clean #清理public的内容","text":"常见命令12345678hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面（新建了一个md文件组,但目前不知道怎么用）hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本hexo clean #清理public的内容 缩写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令12hexo s -g #生成并本地预览hexo d -g #生成并上传","categories":[],"tags":[]}]}