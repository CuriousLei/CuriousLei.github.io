{"meta":{"title":"Leida","subtitle":null,"description":"雷答在 Github 上的个人博客","author":"Lei da","url":"http://curiousLei.github.io"},"pages":[],"posts":[{"title":"有符号数与无符号数运算坑点","slug":"cpp0","date":"2019-09-17T06:51:56.629Z","updated":"2019-09-17T08:35:03.689Z","comments":true,"path":"2019/09/17/cpp0/","link":"","permalink":"http://curiousLei.github.io/2019/09/17/cpp0/","excerpt":"","text":"本篇博客来源于我在leetcode上遇到过的一个bug，当我按照如下所示循环条件时12//vector&lt;int&gt; nums;for(k=0;k&lt;nums.size()-2;k++) 输入的nums为空数组的情况下，按照常理nums.size()-2相当于0-2=-2，但是事违人愿，出现了如下报错1Line 923: Char 34: runtime error: reference binding to null pointer of type &apos;value_type&apos; (stl_vector.h) 原因是：vector::size返回unsigned integral类型，即无符号整形，又由于无符号数与有符号数运算时，会默认将有符号数当做无符号数来处理，下面举例说明 -2在16位机内存中存储形式是1111111111111101，即有符号数-2的补码形式，若该补码当成无符号数来处理，则表示十进制的65533，一个很大的数，32位或64位也以此类推，总之0-2的结果也就不等于-2了。如下代码可以输出这个很大的数12345678#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; nums; cout&lt;&lt;nums.size()-1&lt;&lt;endl; return 0;&#125; 输出结果为18446744073709551615，该数值取决于电脑无符号整数的位数。 当然，把-2去掉之后，便不会报错，因为直接将nums.size()当成0来处理 无符号数与有符号数的区别 无符号类型能保存2倍于有符号类型的数据，因为腾出来一个符号位 感觉这是c++编程中一大坑点，需要多多注意","categories":[],"tags":[]},{"title":"docker相关命令总结","slug":"dockerCommands","date":"2019-07-10T01:41:15.879Z","updated":"2019-07-10T01:56:28.148Z","comments":true,"path":"2019/07/10/dockerCommands/","link":"","permalink":"http://curiousLei.github.io/2019/07/10/dockerCommands/","excerpt":"","text":"启动容器 1docker run --name tomcat --net=host -d tomcat:latest docker容器开启一个终端 1docker exec -it testv4 /bin/bash docker私有网络创建容器 1docker run --name voipBridge -e TZ=&quot;Asia/Shanghai&quot; --cap-add=NET_ADMIN --mount src=voip,dst=/voip --network=mynet --ip 172.18.12.2 -p 8081:8081 -p 8082:8082 -p 7443:7443 -p 5090:5090 -p 25060:25060 -p 25061:25061 -p 5061:5061 -p 5066:5066 -p 3306:3306 -p 8021:8021 -p 5070:5070 -p 444:443 -p 81:80 -p 8443:8443 -p 5070:5070/udp -p 5090:5090/udp -p 15060:15060/udp -p 1337:1337/udp -itd centos:6.10 /bin/bash docker开启一个终端 1docker exec -it testv4 /bin/bash 查看正在监听的端口 1netstat -nltp docker镜像导入导出两种方法不可混用 12345docker save ubuntu:load&gt;/root/ubuntu.tardocker load&lt;ubuntu.tardocker export 98ca36&gt; ubuntu.tarcat ubuntu.tar | sudo docker import - ubuntu:import docker 运行mysql容器 1docker run --name mysql4 -e MYSQL_ROOT_PASSWORD=1234567 -d -P mysql docker 挂载volume 1docker run --name mysql4 -e MYSQL_ROOT_PASSWORD=1234567 --mount src=mydata,dst=/var/lib/mysql -d -P mysql docker registry获取存放镜像信息 12curl http://127.0.0.1:5000/v2/_catalogcurl http://127.0.0.1:5000/v2/centos/tags/list docker使用entrypoint时，首行一定要加#!/bin/bash，末尾行一定要加tail -f docker运行registry命令 1docker run --name registry --restart=always --mount src=myregistry,dst=/var/lib/registry -p 5000:5000 -d registry:latest","categories":[],"tags":[]},{"title":"vagrant相关","slug":"vagrant","date":"2019-07-09T13:15:27.250Z","updated":"2019-07-09T13:16:04.125Z","comments":true,"path":"2019/07/09/vagrant/","link":"","permalink":"http://curiousLei.github.io/2019/07/09/vagrant/","excerpt":"","text":"无法挂载共享目录，报错如下 Vagrant was unable to mount VirtualBox shared folders. This is usuallybecause the filesystem &quot;vboxsf&quot; is not available. This filesystem ismade available via the VirtualBox Guest Additions and kernel module.Please verify that these guest additions are properly installed in theguest. This is not a bug in Vagrant and is usually caused by a faultyVagrant box. For context, the command attempted was:mount -t vboxsf -o uid=1000,gid=1000 vagrant_app /vagrant/appThe error output from the command was:mount: unknown filesystem type &apos;vboxsf&apos; 解决办法点击此处 vgrant常用命令 $ vagrant init # 初始化$ vagrant up # 启动虚拟机$ vagrant halt # 关闭虚拟机$ vagrant reload # 重启虚拟机$ vagrant ssh # SSH 至虚拟机$ vagrant suspend # 挂起虚拟机$ vagrant resume # 唤醒虚拟机$ vagrant status # 查看虚拟机运行状态$ vagrant destroy # 销毁当前虚拟机$ vagrant box list # 查看本地box列表$ vagrant box add # 添加box到列表$ vagrant box remove # 从box列表移除","categories":[],"tags":[]},{"title":"git常用命令总结","slug":"gitCommands","date":"2019-07-09T13:12:35.355Z","updated":"2019-07-15T13:52:47.503Z","comments":true,"path":"2019/07/09/gitCommands/","link":"","permalink":"http://curiousLei.github.io/2019/07/09/gitCommands/","excerpt":"","text":"你的初始化例子1[rectangle setX: 10 y: 10 width: 20 height: 20]; 我的 查看客户端用户名邮箱 12git config user.namegit config user.email 修改用户名密码 12git config --global user.name &quot;leida&quot;git config --global user.email &quot;leida@bjfu.edu.cn&quot; 创建仓库后初始化 123456echo &quot;###&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https:....git push -u origin master git clone之后会自动建立remote 同一行文本被不同分支修改过，才会有冲突，只有一个人修改，则不存在冲突，会直接覆盖 1git push -u origin dev 表示将当前分支推送到远程dev分支上，-u表示建立关联，之后就只需要git push 就行 出现refuseing to merge unrelated histories，按如下解决 1git pull origin master --allow-unrelated-histories 关联远程分支 1git push --set-upstream origin hexo","categories":[],"tags":[]},{"title":"软著流程记录","slug":"ruanzhuRecord","date":"2019-07-05T13:05:57.909Z","updated":"2019-06-18T09:17:43.649Z","comments":true,"path":"2019/07/05/ruanzhuRecord/","link":"","permalink":"http://curiousLei.github.io/2019/07/05/ruanzhuRecord/","excerpt":"","text":"软著申请流程1.准备材料http://yewu.bjppb.gov.cn/bjppb/member/login.do?ut=cpy_soft账户：北京林业大学密码：12345678填写申报表格（必须认真填写）2.导师签字：申请表、用印批办单、知识产权承诺书3.张平盖章：用印批办单、知识产权承诺书4.科技处签字：310找老师，说申请软著，就有人说怎么弄。5.学校盖章：红楼310找老师签完字；去101盖学校公章，拿学校法人复印件。6.交付版权局：北京市政服务中心，一层大厅。学校盖章的：一份网上打印的申请书、法人复印件、两个声明。院里盖章的：用印批办单，交给顾京的申请书。 问题及解决方法1.打印申请表 填表的时候，在开发者工具中把IE的内核版本调低（仿真一栏中，文档模式和用户代理字符串都改成IE7）即可正常填写； 打印的时候，同样把IE的内核版本调低（降成IE7貌似还不够，试一下全部调成IE5），即可打印成pdf下载下来，然后检查一下，看看有没有错版或者多页少页（当然也可以直接打印成纸质版）。 2.文档格式 在线填报网站上的“申报须知”（填表的前一步）中有格式说明，仔细读一读，严格按照它的来写，就基本没问题了。两份文档（软件说明和源程序）的格式要求如下： 3、源程序 1份（注：不要装订）（1）按源程序前30页和源程序最后30页提交，第1页为起始页，第60页为结束页。不足60页的需要提交全部源程序。每页不少于50行（结束页可少于50行）。 在每页的右上角通过电脑以阿拉伯数字连续标注页码。除第60页外，每页不能出现半页。源程序须添加页眉，页眉处务必写清软件的名称（与全称或简称一致）及版本号。（2）源程序中作者应是著作权人。（3）源程序中日期须在开发完成日期之前。（4）源程序中的名称须与申请表中全称或简称一致。4、文档 1份（注：不要装订）（1）设计说明书、用户手册、操作手册、使用说明等（任选一种）。（2）按文档前30页和文档最后30页提交。第1页为起始页，第60页为结束页。不足60页的需要提交全部文档。每页不少于30行（页中有插图或结束页可少于30行）。在正文的右上角通过电脑以阿拉伯数字标注连续页码。除第60页外，每页不能出现半页。文档须添加页眉，页眉处务必写清软件的名称（与全称或简称一致）及版本号。文档可以不要封面，但必须在文档的正文第一页标题中写清楚文档的种类。（比如：微软操作系统使用说明书；微软操作系统设计说明书；微软操作系统用户手册；微软操作系统操作手册）。（3）文档中作者应是著作权人。（4）文档中的日期须在软件开发完成日期之前。（5）文档中的名称须与申请表中全称或简称一致。 申请表中软件名称尽量写xxx平台，xxx软件，xxx系统，否则可能不给过；所有材料中软件名字要统一。 3.市政厅办理注意 身份证复印件正反面在同一页，单面打印； 如果被指出文档格式问题，不用慌，可以想办法当场改一改，市政厅楼上可以打印；但如果申请表有问题，就必须再跑一趟了，因为要重新盖章（拿着新的申请表直接去红楼101盖章即可，旧的会被老师撕掉）； 如果工作人员建议你直接去版权中心办软著，不用理她，因为版权中心的电话永远打不通，去了之后还会发现那边要的申请表格式和咱们的不一样（要带条码的那种）。","categories":[],"tags":[]},{"title":"linux常用命令总结","slug":"linux常用命令总结","date":"2019-07-05T13:05:57.892Z","updated":"2019-07-10T01:56:30.486Z","comments":true,"path":"2019/07/05/linux常用命令总结/","link":"","permalink":"http://curiousLei.github.io/2019/07/05/linux常用命令总结/","excerpt":"","text":"根目录下查找名称前缀为my的文件(文件夹) 1find / -name &apos;my&apos; linux向linux复制文件，-P（大写P）表示端口号（默认22） 1scp -P 2233 passwordModify_encrypt.php root@118.192.66.57:/var/www/opensips-cp/web/ ssh远程登录（小写p） 1ssh -p 2233 root@118.192.66.57 windows下向linux拷贝文件 1pscp -l leida file.zip 192.168.50.24:/home/leida/ 查找目录下包含某一字段的文件 1grep &quot;client&quot; ./ -nr iptables添加开放端口 123456789iptables -A INPUT -p tcp --dport 80 -j ACCEPTservice iptables saveservice iptables restart-A 指append添加规则(末尾)，-I指插入，-D指删除INPUT指输入数据包，相对的是OUTPUT--dport指目的端口，相对的是sport源端口-j ACCEPT 表示动作，相对的是DROP注意：新添加的规则要插入到 RH-Firewall-1-INPUT 之前才能生效，具体原因有待探究 ubuntu下卸载apache2 123456apt purge remove apache2apt purge remove apache2.2-commonapt autoremovefind /etc/ -name &quot;*apache*&quot; | xargs rm -rfrm -rf /var/www 查看linux版本 123cat /etc/issue#适合所有版本系统cat /etc/redhat-release#这种方法只适合Redhat系的Linuxuname -a#查看系统内核版本 查看仓库包 1yum repolist all centos7加载本地光盘yum源 1234567891011121314mount /dev/cdrom/ /mnt/cd /etc/mv yum.repos.d yum.repos.d.bakmkdir yum.repos.dvim yum.repos.d/Centos-Local.repo[Local]name=Local Yumbaseurl=file:///mnt/gpgcheck=0enabled=1yum clean yum makecache centos修改root密码https://blog.csdn.net/akipa11/article/details/81395386 nginx相关命令 123456/usr/local/nginx/sbin/nginx# 启动/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf# 检查配置是否正确/usr/local/nginx/sbin/nginx -s reload# 修改配置后使配置生效 centos7命令行和图形界面互相切换 1234vim /etc/inittabsystemctl get-default systemctl set-default multi-user.targetsystemctl set-default multi-user.target 创建多层文件夹 12mkdir -p demoCA/newcertstouch ./demoCA/index.txt ./demoCA/serial #创建多个文件 grep满足多个可选关键字 1grep -E &quot;me|data&quot; meDec.php grep排除字段 1grep -v &quot;message&quot; meDec.php 删除多级目录下同一格式的文件 1find ./ -name *.o -exec rm -rf &#123;&#125; \\; apache2加载php7.0 1234apt purge libapache2-mod-php7.0 libapache2-mod-phpapt install libapache2-mod-php7.0 libapache2-mod-phpa2enmod php7.0# 不是a2enmod php 为用户添加sudo 123chmod 640 /etc/sudoersleida ALL=(ALL) ALLchmod 440 /etc/sudoers 获取外网ip 1curl icanhazip.com 获取本机ip 123456#方法一ip route get 8.8.8.8 | awk &apos;&#123;print $NF; exit&#125;&apos;#方法二ethName=$(ip route show | grep &apos;default&apos;| awk &apos;&#123;print $5&#125;&apos;)ipAddr=$(ip addr | grep $ethName&apos;:&apos; -A2 | tail -n1 | awk &apos;&#123;print $2&#125;&apos; | cut -f1 -d &apos;/&apos;)echo $ipAddr linux系统时间 123456781.date //查看本地2.hwclock --show //查看硬件的时间3.如果硬件的时间是对不上，那就对硬件的时间进行修改、4.hwclock --set --date &apos;2016-01-08 15:15:15&apos; //设置硬件时间5.hwclock --hctosys //设置系统时间和硬件时间同步6.clock -w //保存时钟7.最后在通过重启，init 6 （reboot） //重启后，查看系统时间是否真正生效 添加用户 12useradd leidapasswd leida 网卡未启动时，通过该命令来自动获取ip 1dhclient ip配置文件 12 daemon.json 12#里面不能写注释#客户端加上 &quot;insecure-registries&quot;: [ &quot;192.168.50.161:5000&quot;]才能通过http访问，否则需要配置https centos6更新yum源 12345678910111213141516171、备份cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d//CentOS-Base.repo.ori2、下载新的CentOS-Base.repo 到/etc/yum.repos.d/wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo# -O表示重命名3、清理 yum clean all4、更新缓存yum makecache#yum install tree -yyum update -y 删除mysql 1234567yum remove mysql mysql-server mysql-libs mysql-server; find / -name mysql 将找到的相关东西delete掉； rpm -qa|grep mysql(查询出来的东东yum remove掉) rpm -e mysql相关文件 centos下载service 1yum install initscripts -y centos下载telnet 12yum install xinetdyum install telnet yum下载crontab 1yum -y install vixie-cron 刚开新虚拟机配置网络 123456789101112#网络配置文件：/etc/sysconfig/network-scripts/ifcfg-ens33#static assignmentNM_CONTROLLED=no #表示该接口将通过该配置文件进行设置，而不是通过网络管理器进行管理ONBOOT=yes #开机启动BOOTPROTO=static #静态IPIPADDR=192.168.50.161 #本机地址NETMASK=255.255.255.0 #子网掩码GATEWAY=192.168.50.1 #默认网关DNS1=180.76.76.76DNS2=8.8.8.8systemctl restart network 下载netstat 1yum -y install net-tools run.sh的执行路径是根目录，不是/root/ 查看当前文件夹下文件大小 1du -sh * vim相关命令 1234:set nu#显示行号:32,56d#删除上下行号之间的代码 firewall相关 123456#添加开放端口firewall-cmd --zone=public --add-port=80/tcp --permanent #查看所有打开的端口firewall-cmd --zone=public --list-ports#更新防火墙规则firewall-cmd --reload 选择时区 1tzselect","categories":[],"tags":[]},{"title":"https搭建(自签名证书)","slug":"https搭建(自签署证书)","date":"2019-07-05T13:05:57.861Z","updated":"2019-07-05T13:42:34.459Z","comments":true,"path":"2019/07/05/https搭建(自签署证书)/","link":"","permalink":"http://curiousLei.github.io/2019/07/05/https搭建(自签署证书)/","excerpt":"","text":"上一篇博客探究了https（ssl）的原理，为了贯彻理论落实于实践的宗旨，本文将记录我搭建https的实操流程，使用Apache2+ubuntu+opensssl 1.使用自签证书配置https一般来讲，正式的上线项目都需要购买域名，并且向权威机构申请证书。但本次工作属于测试环境，所以一切从简，我们使用openssl工具生自签名的CA证书以及服务器证书，来搭建https。具体步骤如下： （1）安装apache2、openssl(ubuntu16.04)安装过程此处不做赘述，很简单。Apache2安装完成并启动后，通过http://ipaddress 来测试，如下图所示，说明安装成功 （2）制作证书生成自签CA证书 生成CA私钥 openssl genrsa -out ca.key 2048 生成CA证书 openssl req -new -x509 -days 3650 -key ca.key -out ca.crt -config /etc/ssl/openssl.cnf openssl.cnf的路径注意填对。最后在当前目录下生成的ca.key即为CA私钥，ca.crt即为CA证书（包含CA公钥） 生成服务器证书 生成服务器私钥 openssl genrsa -out server.key 2048 生成服务器签署申请文件 openssl req -new -out server.csr -key server.key -config /etc/ssl/openssl.cnf 需要填写服务器信息，如实填写即可。需要注意Common Name 需要与openssl.cnf 中配置的域名相对应（alt_names），否则客户端无法验证。该命令最后生成的server.csr即为申请文件。openssl.cnf的具体配置见下文。 在签署证书之前需要确认openssl.cnf中的配置，如下所示： #根据实际情况修改，将match改成optional，否则ca.crt必须与server.csr中的各个字段值一致才能签署[ policy_match ]countryName = optionalstateOrProvinceName = optionalorganizationName = optionalorganizationalUnitName = optionalcommonName = suppliedemailAddress = optional# 确保req下存在以下2行（默认第一行是有的，第2行被注释了）[ req ]distinguished_name = req_distinguished_namereq_extensions = v3_req# 确保req_distinguished_name下没有 0.xxx 的标签，有的话把0.xxx的0. 去掉[ req_distinguished_name ]countryName = Country Name (2 letter code)countryName_default = XXcountryName_min = 2countryName_max = 2stateOrProvinceName = State or Province Name (full name)localityName = Locality Name (eg, city)localityName_default = Default CityorganizationName = Organization Name (eg, company)organizationName_default = Default Company LtdorganizationalUnitName = Organizational Unit Name (eg, section)commonName = Common Name (eg, your name or your server\\&apos;s hostname)commonName_max = 64emailAddress = Email AddressemailAddress_max = 64#添加一行subjectAltName=@alt_names[ v3_req ]# Extensions to add to a certificate requestbasicConstraints = CA:FALSEkeyUsage = nonRepudiation, digitalSignature, keyEnciphermentsubjectAltName=@alt_names#新增alt_names,注意括号前后的空格，DNS.x 的数量可以自己加#如果没有IP这一项，浏览器使用IP访问时验证无法通过[ alt_names ]IP.1 = 192.168.50.115DNS.1 = dfe.leida.orgDNS.2 = ex.abcexpale.net 使用CA证书和私钥签署服务器证书 openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key -extensions v3_req -config /etc/ssl/openssl.cnf 直接运行该签署命令，会报错，提示缺少某些文件和目录。在当前目录下把相应的文件及文件夹创建上即可解决，如下 mkdir -p demoCA/newcertstouch ./demoCA/index.txt ./demoCA/serialecho &quot;01&quot;&gt;&gt; ./demoCA/serial 创建完毕后，运行签署命令即可完成服务器证书的制作。当前目录下生成的server.crt即为服务器证书，server.key为服务器私钥 （3）配置apache2 启用ssl模块(此处可使用a2enmod命令) a2enmod ssl 启用ssl站点 a2ensite default-ssl 加入监听端口443(因为https默认采用443端口，有别于http的80) listen 80 443# /etc/apache2/ports.conf中修改成如上所示即可 配置证书以及私钥的路径 SSLCertificateFile /etc/ssl/certs/server.crtSSLCertificateKeyFile /etc/ssl/private/server.key# 在/etc/apache2/sites-available/default-ssl.conf中修改如上参数，确认证书和私钥的路径正确无误 重启apache2，搞定！ 2.使用浏览器测试https上述的制作证书步骤，已经是我测试结束、爬完坑后的正确教程，下文则是填坑记录。 实际上，我一开始按照网上的方法搭建完https后，出现过一些问题。使用浏览器访问https://ipaddress 会跳出如下提示界面实际上此时浏览器已获取到服务器证书server.crt，只是由于某些原因无法验证它。若选择高级选项中的“继续浏览”时，同样可以正常跳转至对应的页面，这时相当于强行让浏览器接受该证书，同时接受服务器公钥。在测试环境下，这样完全OK。但是，强迫症的我还是想让导航栏上出现安全的小锁，红叉叉看着很难受啊。 下面总结记录一下使用浏览器（chrome）测试的过程中遇到的问题以及解决方法 （1）客户端缺少CA证书点击导航栏左侧的感叹号，查看证书，如下图所示此时浏览器已获取到server.crt，由于其对应的CA证书不存在于“受信任的根证书机构”中，所以无法验证server.crt 我们需要将CA证书（上文使用OpenSSL生成的ca.crt）安装至客户端系统中的“受信任的根证书机构”中，保证浏览器可通过此CA证书来验证服务器证书server.crt。安装过程很简单，双击如下所示安装即可 安装结束后，重启浏览器，再次打开证书，如下所示 此时浏览器已经可以使用ca证书来验证server.crt，已完成了很重要的一步，但我的chrome浏览器依然没有出现小锁 （2）缺少使用者备用名称完成上一步后，浏览器的导航栏依然显示不安全，我打开开发者工具，查看security得知，是服务器证书缺少“使用者备用名称”所导致，如下图所示。如何解决这个问题，我参考了这个博客（http://blog.51cto.com/colinzhouyj/1566438 ），即修改openssl.cnf的部分配置，前文“制作证书”步骤中已经整合过此处的配置内容。修改完，重新签署证书，重启apache2，再次运行，Subject Alternative Name missing的问题解决。 （3）IP验证不通过在上一步操作中，我添加完几条DNS之后，发现chrome依然报错，如下图所示我用的是虚拟机环境，没有域名解析，而是直接通过IP来访问站点的，又由于证书中不存在IP信息，是无法跟URL中的IP进行比对的，因此浏览器无法通过证书验证。该问题有两个解决方法 （1）在证书中添加IP地址。在openssl.cnf中配置使用者可选名称时，添加一条IP地址，即可保证浏览器通过对IP的验证，重新签署配置运行后，结果如下 打开证书，使用者可用名称字段如下 （2）使用域名访问。在客户机的host文件中配置域名与IP的映射，直接使用域名来访问站点（证书中包含域名），即可通过验证，如下所示 使用这两种方法的其中一种，迟迟不肯露面的小锁终于出现了，打开security也是一片绿色，大功告成。但是，要注意一点，不同浏览器对于证书的验证方式可能存在差异。按照我的操作，firefox依然无法验证，暂时没细究，但chrome和edge浏览器都可以完美运行。","categories":[],"tags":[]},{"title":"https原理总结","slug":"https原理总结","date":"2019-07-05T13:05:57.844Z","updated":"2019-07-05T13:42:30.230Z","comments":true,"path":"2019/07/05/https原理总结/","link":"","permalink":"http://curiousLei.github.io/2019/07/05/https原理总结/","excerpt":"","text":"最近在公司项目的服务器上做一些内部接口，要求使用https，于是花时间研究了一波。我们熟知的http在传输时未对数据进行加密，在传输一些敏感信息时存在着不小的安全隐患。因此，https在http的基础上加上了SSL（Secure Sockets Layer）加密，以保障数据的安全传输。如今使用的TLS实际上是SSL的升级版本。具体有关https的概念可参考百科https介绍 1.https原理探究https的保障信息安全的机制，其实用一句话就能概括：client与server通过非对称加密来协商一个对称秘钥，然后CS两端使用该对称秘钥来进行数据的加密解密，完成数据交互。所以数据传输时，实际上走的是对称加密。当然理解这句话前提，需要明白对称和非对称加密的原理，本文不做讨论。 原理概况SSL加密机制的大致过程： client发送请求 server返回证书 client验证并取出证书中的公钥 client生成随机数，并使用服务器公钥将其加密，把得到的密文发送给server server使用私钥解密，得到随机数 两端各自通过随机数生成对称秘钥，协商完成 数字证书与数字签名在详细介绍握手环节之前，我想先说说数字数字证书的起因及原理，数字证书是整个SSL加密的核心与纽带。首先，在使用非对称加密传输之前，客户端需要获取服务器公钥，这里存在一种攻击方式，即中间方使用自己的公钥替换服务器的公钥发送给客户端，再通过自己的私钥获取客户端传来的非对称加密内容，从而实现篡改以及窃听。为了方便理解，网上有一张图我直接拿来用了，如下所示。为了防止获取公钥过程遭到第三方的掉包等之类的破坏，于是便有了证书机制，下图为服务器证书的签署以及验证的大致流程。 证书包含三部分内容 证书内容（服务器公钥、服务器信息等） 加密算法（加密算法、哈希算法） 密文（使用哈希算法计算证书内容得到哈希摘要，再使用CA私钥加密该摘要即得到密文，该过程称为数字签名） 验证数字证书 客户端验证服务器证书时，需要获取到你的上一级CA证书，从而得到取CA公钥，使用CA公钥对证书中的密文解密得到哈希摘要，同时客户端使用同样的哈希算法对服务器证书内容计算得到另一个哈希摘要，若这两个摘要相等，则证明证书合法。 上述的哈希签名也称为数字指纹法，该方法的精髓在于，相同的明文通过哈希计算得到的摘要，一定是相同的，而只要两份明文只要有一丝丝区别，其对应的哈希值也是不同的。因此，若第三方替换了证书中的公钥，根据证书内容计算出的新的摘要一定与密文中的摘要有所差异的，故可以轻松地判断证书不合法。 疑问 （1）既然是使用上级CA证书来验证服务器证书，那如何证明上级CA证书的合法性？ 这涉及到一个证书信任链的问题。上级证书通过更高一级的CA根证书来确定其合法性，这是一个递归向上的过程，直到最顶层根证书。顶层CA根证书是整个安全体系的根本。 （2）前文提到的攻击方式，只替换公钥显然是不行，那如果第三方把整个证书都替换成自己的证书（因为CA机构可以给任何人签名，黑客也可以），这样的话客户端的验证是不是可以通过？ 答案当然是否定的，很简单，因为证书内容里的服务器信息是唯一的、不可复制的，例如域名，若替换整个证书，域名也会变成黑客自己的域名，浏览器不会接受域名和请求内容不匹配的证书。比如说，浏览器请求了 baidu.com，结果返回了个google.com的证书，毫无疑问会立即排除掉。 保证了服务器公钥安全抵达客户端手中，后续的对话秘钥的协商便也能顺理成章地进行。因此https所采用的SSL机制是绝对安全的，几乎没有人能够破解。当然，有得必有失，https花费的开销也远高于http。 SSL握手过程 https握手原理图 理解了上文所讲的证书机制，其实SSL加密机制也基本容易理解了，下面细究一下SSL握手过程，此处结合上方交互原理图进行分析（1） Client Helllo。客户端发送初次请求，请求内容包含版本信息，加密套件候选列表，压缩算法候选列表，随机数random_1，扩展字段等信息，以明文传输； （2）服务器选择客户端支持的加密套件、压缩算法、协议版本等，生成随机数random_2； （3）服务器将上述算法以及随机数等发送给客户端； （4）服务器发送服务器数字证书； （5）客户端接收服务器选择的算法以及随机数等，验证数字证书。若证书验证通过，或者用户接受了不可信证书，客户端获取服务器公钥，同时会生成随机数random_3，并使用服务器公钥加密该随机数得到密文； （6）客户端将第五步得到的密文传给服务器，由于公钥加密的内容只能使用私钥解开，所以random_3无法被窃听； （7）Change cipher Spec。客户端通知服务器协商完成； 此时客户端已存有三个随机数random_1、random_2和random_3，前两个是可以被截获的，第三个是私密的，根据这三者可计算得出对话秘钥，即enc_key=Fuc(random_1, random_2, random_3) （8）客户端结合之前所有通信参数的 hash 值与其它相关信息生成一段数据，并使用对话秘钥enc_key和算法将其加密，得到密文encrypted_handshake_message，将其发送给服务器进行验证； （9）服务器使用私钥解密第六步得到的密文，得到随机数random_3，此时服务器也拥有了三个随机数random_1、random_2和random_3，同样可计算出对话秘钥enc_key，至此双方共享对称加密秘钥的目的已达成；计算之前所有接收信息的 hash 值，然后解密客户端发送的 encrypted_handshake_message，验证数据和密钥正确性; （10）类似7和8，服务器通知客户端协商完成，同时计算发送encrypted_handshake_message。客户端以同样的方式验证encrypted_handshake_message，握手完成。 完成握手之后，服务器和客户端都使用相同的对话秘钥enc_key，对消息内容进行加密，实现安全通信。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-07-05T13:05:57.835Z","updated":"2018-07-09T06:28:05.440Z","comments":true,"path":"2019/07/05/hello-world/","link":"","permalink":"http://curiousLei.github.io/2019/07/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"用户评论情感极性判别","slug":"用户评论情感极性判别","date":"2018-07-09T10:34:52.000Z","updated":"2018-07-09T10:35:12.340Z","comments":true,"path":"2018/07/09/用户评论情感极性判别/","link":"","permalink":"http://curiousLei.github.io/2018/07/09/用户评论情感极性判别/","excerpt":"本文章介绍百度点石平台上的一个训练赛的赛题代码，赛题是包括用户评论文字的情感判别的分类问题，赛题链接戳此处 数据预处理 使用测试数据和训练数据生成语料库 import numpy as npimport jiebaimport codecs# 该函数作用是读取文件def load_data(file_path): data_set = [] with open(file_path, &apos;r&apos;) as lines: for line in lines: line=line.strip() values=line.split(&quot;\\t&quot;) data_set.append(values) np.array(data_set) # print(data_set[0]) return data_setdataAll=load_data(&apos;data_train.csv&apos;)dataTest=load_data(&apos;data_test.csv&apos;)csvfile = codecs.open(&quot;fenci_result.csv&quot;, &apos;w&apos;, &apos;utf-8&apos;)#f=open(&apos;fenci_result.txt&apos;,&apos;a&apos;)for item in dataAll: seg_list=jieba.cut(item[2])#使用结巴分词 csvfile.write(&quot; &quot;.join(seg_list))#以空格隔开把分好的词写入文件，形成语料#f.close()for item in dataTest: seg_list=jieba.cut(item[-1]) csvfile.write(&quot; &quot;.join(seg_list))","text":"本文章介绍百度点石平台上的一个训练赛的赛题代码，赛题是包括用户评论文字的情感判别的分类问题，赛题链接戳此处 数据预处理 使用测试数据和训练数据生成语料库 import numpy as npimport jiebaimport codecs# 该函数作用是读取文件def load_data(file_path): data_set = [] with open(file_path, &apos;r&apos;) as lines: for line in lines: line=line.strip() values=line.split(&quot;\\t&quot;) data_set.append(values) np.array(data_set) # print(data_set[0]) return data_setdataAll=load_data(&apos;data_train.csv&apos;)dataTest=load_data(&apos;data_test.csv&apos;)csvfile = codecs.open(&quot;fenci_result.csv&quot;, &apos;w&apos;, &apos;utf-8&apos;)#f=open(&apos;fenci_result.txt&apos;,&apos;a&apos;)for item in dataAll: seg_list=jieba.cut(item[2])#使用结巴分词 csvfile.write(&quot; &quot;.join(seg_list))#以空格隔开把分好的词写入文件，形成语料#f.close()for item in dataTest: seg_list=jieba.cut(item[-1]) csvfile.write(&quot; &quot;.join(seg_list)) 利用语料库，使用word2vec工具，生成可备用的模型，用于将句子转化为向量 from gensim.models import word2vecimport logginglogging.basicConfig(format = &apos;%(asctime)s : %(levelname)s : %(message)s&apos;, level = logging.INFO)sentences = word2vec.Text8Corpus(&quot;fenci_result.csv&quot;) # 加载语料model = word2vec.Word2Vec(sentences, size = 400) # 训练skip-gram模型# 保存模型，以便重用model.save(&quot;corpus.model&quot;)model.wv.save_word2vec_format(&quot;corpus.model.bin&quot;, binary = True) 数据训练与测试 感觉训练方式很简陋，有待改善 #本程序用来测试模型#coding=utf-8 import reimport numpy as npimport jiebafrom gensim.models import word2vecimport loggingimport codecsfrom sklearn.decomposition import PCAfrom sklearn.model_selection import train_test_splitfrom sklearn import svmfrom sklearn.metrics import accuracy_score,confusion_matrix, f1_score, precision_score, recall_score, \\ roc_curve # 导入指标库import prettytable # 导入表格库# 该函数作用是读取文件def load_data(file_path): data_set = [] with open(file_path, &apos;r&apos;) as lines: for line in lines: line=line.strip() values=line.split(&quot;\\t&quot;) data_set.append(values) np.array(data_set) # print(data_set[0]) return data_set#写文件def write_result(array, outpuFilePath): with open(outpuFilePath, &apos;w&apos;) as output_file: for i in range(len(array)): output_file.write(&quot;%d,%d\\n&quot; % (i+1,array[i]))#将句子转化为向量def getWordVecs(wordList): vecs = [] for word in wordList: word = word.strip() try: vecs.append(model[word]) except KeyError: continue # vecs = np.concatenate(vecs) return np.array(vecs, dtype = &apos;float&apos;)model = word2vec.KeyedVectors.load_word2vec_format(&quot;corpus.model.bin&quot;, binary = True)# segList=jieba.cut(&apos;烤鸭还是不错的，别的菜没什么特殊的&apos;)# resultList = getWordVecs(segList)# print(sum(np.array(resultList))/2)dataAll=load_data(&apos;data_train.csv&apos;)X=[]y=[]dataAll=np.array(dataAll[:1500])for item in dataAll: #temp=int(item[-1]) #y.append(temp if temp!=0 else 1)#把0都替换成1，先对2和1进行分类 y.append(int(item[-1])) segList=jieba.cut(item[2]) vecList=getWordVecs(segList) if len(vecList) != 0: X.append(sum(np.array(vecList))/len(vecList))X=X[:]x_train=np.array(X)y_train=np.array(y)print(x_train)print(y_train)# x_train = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2], [2, 1], [3, 2]])# print(x_train)# 使用sklearn的PCA进行维度转换model_pca = PCA(n_components=0.95) # 建立PCA模型对象model_pca.fit(x_train) # 将数据集输入模型#model_pca.transform(x_train) # 对数据集进行转换映射newX=model_pca.fit_transform(x_train)#进行转换映射，并将转换后的赋给newXcomponents = model_pca.components_ # 获得转换后的所有主成分(不明白什么意思)components_var = model_pca.explained_variance_ # 获得各主成分的方差components_var_ratio = model_pca.explained_variance_ratio_ # 获得各主成分的方差占比print(&quot;\\n主成分分析：&quot;)print (components) # 打印输出前2个主成分print (len(components_var)) # 打印输出所有主成分的方差print (components_var_ratio) # 打印输出所有主成分的方差占比print(len(newX))print(len(newX[0]))X_train, X_test, y_train, y_test = train_test_split(newX, y_train, test_size=.3, random_state=0)clf = svm.SVC(C=1, kernel=&apos;linear&apos;,decision_function_shape=&apos;ovr&apos;)clf.fit(X_train, y_train)y_hat=clf.predict(X_test)##评价指标accuracy_s = accuracy_score(y_test, y_hat) # 准确率precision_s = precision_score(y_test, y_hat, average=&apos;macro&apos;) # 精确度recall_s = recall_score(y_test, y_hat, average=&apos;macro&apos;) # 召回率f1_s = f1_score(y_test, y_hat, average=&apos;weighted&apos;) # F1得分print(&apos;Accuracy:&apos;)print(accuracy_s)print(&apos;Precision:&apos;)print(precision_s)print(&apos;Recall:&apos;)print(recall_s)print(&apos;f-measure:&apos;)print(f1_s)##混淆矩阵confusion_m = confusion_matrix(y_test,y_hat) # 获得混淆矩阵confusion_matrix_table = prettytable.PrettyTable() # 创建表格实例confusion_matrix_table.add_row(confusion_m[0, :]) # 增加第一行数据confusion_matrix_table.add_row(confusion_m[1, :]) # 增加第二行数据confusion_matrix_table.add_row(confusion_m[2, :]) # 增加第三行数据print (&apos;confusion matrix&apos;)print (confusion_matrix_table) # 打印输出混淆矩阵write_result(y_hat,&apos;print.csv&apos;) 预测阶段 使用所有训练数据训练模型并对test数据进行预测 #本程序用来进行预测#coding=utf-8 import reimport numpy as npimport jiebafrom gensim.models import word2vecimport loggingimport codecsfrom sklearn.decomposition import PCAfrom sklearn.model_selection import train_test_splitfrom sklearn import svm# 该函数作用是读取文件def load_data(file_path): data_set = [] with open(file_path, &apos;r&apos;) as lines: for line in lines: line=line.strip() values=line.split(&apos;\\t&apos;) data_set.append(values) np.array(data_set) # print(data_set[0]) return data_set#写文件def write_result(array, outpuFilePath): with open(outpuFilePath, &apos;w&apos;) as output_file: for i in range(len(array)): output_file.write(&quot;%d,%d\\n&quot; % (i+1,array[i]))#将句子转化为向量def getWordVecs(wordList): vecs = [] for word in wordList: word = word.strip() try: vecs.append(model[word]) except KeyError: continue # vecs = np.concatenate(vecs) return np.array(vecs, dtype = &apos;float&apos;)#对预测数据进行处理def preDataHandle(): preData=load_data(&apos;data_test.csv&apos;) #exit(0) xPre=[] i=0 k=0 for item in preData: i+=1 s=&apos;&apos; for j in range(len(item)): if(j&gt;1): s=&quot;%s%s&quot;%(s,item[j]) segList=jieba.cut(s) vecList=getWordVecs(segList) if len(vecList) != 0: xPre.append(sum(np.array(vecList))/len(vecList)) else: k+=1 print(&apos;存在vecList长度为0的情况&apos;) print(item) x_pre=np.array(xPre) model_pca = PCA(n_components=factorNum) # 建立PCA模型对象 model_pca.fit(x_pre) # 将数据集输入模型 x_pre=model_pca.fit_transform(x_pre)#进行转换映射 return x_premodel = word2vec.KeyedVectors.load_word2vec_format(&quot;corpus.model.bin&quot;, binary = True)dataAll=load_data(&apos;data_train.csv&apos;)X=[]y=[]#dataAll=np.array(dataAll[:1500])for item in dataAll: print(item) y.append(int(item[-1])) segList=jieba.cut(item[2]) vecList=getWordVecs(segList) if len(vecList) != 0: X.append(sum(np.array(vecList))/len(vecList)) else: print(item)X=X[:]x_train=np.array(X)y_train=np.array(y)model_pca = PCA(n_components=0.95) # 建立PCA模型对象model_pca.fit(x_train) # 将数据集输入模型#model_pca.transform(x_train) # 对数据集进行转换映射newX=model_pca.fit_transform(x_train)#进行转换映射，并将转换后的赋给newXfactorNum=len(newX[0])clf = svm.SVC(C=1, kernel=&apos;linear&apos;,decision_function_shape=&apos;ovr&apos;)clf.fit(newX, y_train)x_pre=preDataHandle()y_pre=clf.predict(x_pre)write_result(y_pre,&apos;output.csv&apos;)print(&apos;Project has been finished successfully!&apos;) 比赛平台上计算出的结果f1-score为0.7249，很低，希望再接再厉","categories":[],"tags":[]},{"title":"Hello,Hexo!","slug":"Hello-Hexo","date":"2018-07-09T06:58:15.000Z","updated":"2018-07-09T08:35:20.314Z","comments":true,"path":"2018/07/09/Hello-Hexo/","link":"","permalink":"http://curiousLei.github.io/2018/07/09/Hello-Hexo/","excerpt":"常见命令hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面（新建了一个md文件组,但目前不知道怎么用）hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本hexo clean #清理public的内容","text":"常见命令hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面（新建了一个md文件组,但目前不知道怎么用）hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本hexo clean #清理public的内容 缩写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令hexo s -g #生成并本地预览hexo d -g #生成并上传","categories":[],"tags":[]}]}